{"version":3,"file":"index.min.js","sources":["../src/index.js"],"sourcesContent":["const ARROW_EXP = 'ArrowFunctionExpression';\n\nexport default {\n\tname: 'arrow',\n\n\tinit(jsep) {\n\t\t// arrow-function expressions: () => x, v => v, (a, b) => v\n\t\tjsep.addBinaryOp('=>', 0.1, true);\n\n\t\t// this hook searches for the special case () => ...\n\t\t// which would normally throw an error because of the invalid LHS to the bin op\n\t\tjsep.hooks.add('gobble-expression', function gobbleEmptyArrowArg(env) {\n\t\t\tthis.gobbleSpaces();\n\t\t\tif (this.code === jsep.OPAREN_CODE) {\n\t\t\t\tconst backupIndex = this.index;\n\t\t\t\tthis.index++;\n\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tif (this.code === jsep.CPAREN_CODE) {\n\t\t\t\t\tthis.index++;\n\n\t\t\t\t\tconst biop = this.gobbleBinaryOp();\n\t\t\t\t\tif (biop === '=>') {\n\t\t\t\t\t\t// () => ...\n\t\t\t\t\t\tconst body = this.gobbleBinaryExpression();\n\t\t\t\t\t\tif (!body) {\n\t\t\t\t\t\t\tthis.throwError(\"Expected expression after \" + biop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenv.node = {\n\t\t\t\t\t\t\ttype: ARROW_EXP,\n\t\t\t\t\t\t\tparams: null,\n\t\t\t\t\t\t\tbody,\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.index = backupIndex;\n\t\t\t}\n\t\t});\n\n\t\tjsep.hooks.add('after-expression', function fixBinaryArrow(env) {\n\t\t\tupdateBinariesToArrows(env.node);\n\t\t});\n\n\t\tfunction updateBinariesToArrows(node) {\n\t\t\tif (node) {\n\t\t\t\t// Traverse full tree, converting any sub-object nodes as needed\n\t\t\t\tObject.values(node).forEach((val) => {\n\t\t\t\t\tif (val && typeof val === 'object') {\n\t\t\t\t\t\tupdateBinariesToArrows(val);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (node.operator === '=>') {\n\t\t\t\t\tnode.type = ARROW_EXP;\n\t\t\t\t\tnode.params = node.left ? [node.left] : null;\n\t\t\t\t\tnode.body = node.right;\n\t\t\t\t\tif (node.params && node.params[0].type === jsep.SEQUENCE_EXP) {\n\t\t\t\t\t\tnode.params = node.params[0].expressions;\n\t\t\t\t\t}\n\t\t\t\t\tdelete node.left;\n\t\t\t\t\tdelete node.right;\n\t\t\t\t\tdelete node.operator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n"],"names":["name","init","jsep","updateBinariesToArrows","node","Object","values","forEach","val","operator","type","params","left","body","right","SEQUENCE_EXP","expressions","addBinaryOp","hooks","add","env","this","gobbleSpaces","code","OPAREN_CODE","backupIndex","index","CPAREN_CODE","biop","gobbleBinaryOp","gobbleBinaryExpression","throwError"],"mappings":"AAEA,MAAe,CACdA,KAAM,QAENC,KAAKC,GAuCJ,SAASC,EAAuBC,GAC3BA,IAEHC,OAAOC,OAAOF,GAAMG,SAASC,IACxBA,GAAsB,iBAARA,GACjBL,EAAuBK,MAIH,OAAlBJ,EAAKK,WACRL,EAAKM,KAtDQ,0BAuDbN,EAAKO,OAASP,EAAKQ,KAAO,CAACR,EAAKQ,MAAQ,KACxCR,EAAKS,KAAOT,EAAKU,MACbV,EAAKO,QAAUP,EAAKO,OAAO,GAAGD,OAASR,EAAKa,eAC/CX,EAAKO,OAASP,EAAKO,OAAO,GAAGK,oBAEvBZ,EAAKQ,YACLR,EAAKU,aACLV,EAAKK,WAvDfP,EAAKe,YAAY,KAAM,IAAK,GAI5Bf,EAAKgB,MAAMC,IAAI,qBAAqB,SAA6BC,GAEhE,GADAC,KAAKC,eACDD,KAAKE,OAASrB,EAAKsB,YAAa,CACnC,MAAMC,EAAcJ,KAAKK,MAIzB,GAHAL,KAAKK,QAELL,KAAKC,eACDD,KAAKE,OAASrB,EAAKyB,YAAa,CACnCN,KAAKK,QAEL,MAAME,EAAOP,KAAKQ,iBAClB,GAAa,OAATD,EAAe,CAElB,MAAMf,EAAOQ,KAAKS,yBASlB,OARKjB,GACJQ,KAAKU,WAAW,6BAA+BH,QAEhDR,EAAIhB,KAAO,CACVM,KA7BW,0BA8BXC,OAAQ,KACRE,KAAAA,KAKHQ,KAAKK,MAAQD,MAIfvB,EAAKgB,MAAMC,IAAI,oBAAoB,SAAwBC,GAC1DjB,EAAuBiB,EAAIhB"}