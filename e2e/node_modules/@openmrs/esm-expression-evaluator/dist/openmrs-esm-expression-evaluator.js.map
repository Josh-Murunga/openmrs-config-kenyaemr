{"version":3,"file":"openmrs-esm-expression-evaluator.js","mappings":"iFACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFV,EAAyBC,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,GAAO,G,6NC2F9D,MAAMC,EAIMC,qBAEV,MAAO,OACR,CAKAC,kBACC,MAAO,wCAA0CF,EAAKC,OACvD,CAQAC,kBAAkBC,GAGjB,OAFAH,EAAKI,aAAeC,KAAKC,IAAIH,EAAQI,OAAQP,EAAKI,cAClDJ,EAAKQ,UAAUL,GAAW,EACnBH,CACR,CASAE,mBAAmBC,EAASM,EAAYC,GASvC,OARAV,EAAKW,cAAgBN,KAAKC,IAAIH,EAAQI,OAAQP,EAAKW,eACnDX,EAAKY,WAAWT,GAAWM,EACvBC,EACHV,EAAKa,kBAAkBC,IAAIX,GAG3BH,EAAKa,kBAAkBE,OAAOZ,GAExBH,CACR,CAOAE,yBAAyBc,GAExB,OADAhB,EAAKiB,4BAA4BH,IAAIE,GAC9BhB,CACR,CAQAE,kBAAkBgB,EAAcC,GAE/B,OADAnB,EAAKoB,SAASF,GAAgBC,EACvBnB,CACR,CAOAE,qBAAqBC,GAKpB,cAJOH,EAAKQ,UAAUL,GAClBA,EAAQI,SAAWP,EAAKI,eAC3BJ,EAAKI,aAAeJ,EAAKqB,aAAarB,EAAKQ,YAErCR,CACR,CAMAE,2BAIC,OAHAF,EAAKQ,UAAY,CAAC,EAClBR,EAAKI,aAAe,EAEbJ,CACR,CAOAE,4BAA4Bc,GAE3B,OADAhB,EAAKiB,4BAA4BF,OAAOC,GACjChB,CACR,CAOAE,sBAAsBC,GAQrB,cAPOH,EAAKY,WAAWT,GAEnBA,EAAQI,SAAWP,EAAKW,gBAC3BX,EAAKW,cAAgBX,EAAKqB,aAAarB,EAAKY,aAE7CZ,EAAKa,kBAAkBE,OAAOZ,GAEvBH,CACR,CAMAE,4BAIC,OAHAF,EAAKY,WAAa,CAAC,EACnBZ,EAAKW,cAAgB,EAEdX,CACR,CAOAE,qBAAqBgB,GAEpB,cADOlB,EAAKoB,SAASF,GACdlB,CACR,CAMAE,2BAGC,OAFAF,EAAKoB,SAAW,CAAC,EAEVpB,CACR,CAOIgB,WACH,OAAOM,KAAKC,KAAKC,OAAOF,KAAKG,MAC9B,CAKIC,WACH,OAAOJ,KAAKC,KAAKI,WAAWL,KAAKG,MAClC,CAOAG,YAAYL,GAGXD,KAAKC,KAAOA,EACZD,KAAKG,MAAQ,CACd,CAMAvB,aAAaqB,GACZ,OAAO,IAAKvB,EAAKuB,GAAOM,OACzB,CAOA3B,oBAAoBV,GACnB,OAAOa,KAAKC,IAAI,KAAMlB,OAAO0C,KAAKtC,GAAKuC,KAAIC,GAAKA,EAAEzB,SACnD,CAOAL,sBAAsB+B,GACrB,OAAQA,GAAM,IAAMA,GAAM,EAC3B,CAOA/B,wBAAwBgC,GACvB,OAAOlC,EAAKY,WAAWsB,IAAW,CACnC,CAOAhC,yBAAyB+B,GACxB,OAASA,GAAM,IAAMA,GAAM,IACzBA,GAAM,IAAMA,GAAM,KAClBA,GAAM,MAAQjC,EAAKY,WAAWuB,OAAOC,aAAaH,KAClDjC,EAAKiB,4BAA4BoB,IAAIF,OAAOC,aAAaH,GAC5D,CAMA/B,wBAAwB+B,GACvB,OAAOjC,EAAKsC,kBAAkBL,IAAOjC,EAAKuC,eAAeN,EAC1D,CAOAO,WAAWC,GACV,MAAMC,EAAQ,IAAIC,MAAMF,EAAU,iBAAmBnB,KAAKG,OAG1D,MAFAiB,EAAMjB,MAAQH,KAAKG,MACnBiB,EAAME,YAAcH,EACdC,CACP,CAQAG,QAAQC,EAAMC,GACb,GAAI/C,EAAKgD,MAAMF,GAAO,CACrB,MAAMG,EAAM,CAAEC,QAAS5B,KAAMyB,QAE7B,OADA/C,EAAKgD,MAAMG,IAAIL,EAAMG,GACdA,EAAIF,IACZ,CACA,OAAOA,CACR,CAOAK,WAAWN,GACV,GAAI9C,EAAKgD,MAAMF,GAAO,CACrB,MAAMG,EAAM,CAAEC,QAAS5B,MAKvB,OAJAtB,EAAKgD,MAAMF,GAAMO,MAAK,SAAUC,GAE/B,OADAA,EAAS1D,KAAKqD,EAAIC,QAASD,GACpBA,EAAIF,IACZ,IACOE,EAAIF,IACZ,CACD,CAKAQ,eACC,IAAItB,EAAKX,KAAKI,KAEd,KAAOO,IAAOjC,EAAKwD,YAChBvB,IAAOjC,EAAKyD,UACZxB,IAAOjC,EAAK0D,SACZzB,IAAOjC,EAAK2D,SACd1B,EAAKX,KAAKC,KAAKI,aAAaL,KAAKG,OAElCH,KAAKuB,QAAQ,gBACd,CAMAhB,QACCP,KAAKuB,QAAQ,cACb,MAAMe,EAAQtC,KAAKuC,oBAGbd,EAAwB,IAAjBa,EAAMrD,OACfqD,EAAM,GACP,CACDE,KAAM9D,EAAK+D,SACXC,KAAMJ,GAER,OAAOtC,KAAKuB,QAAQ,YAAaE,EAClC,CAOAc,kBAAkBI,GACjB,IAAgBC,EAAMnB,EAAlBa,EAAQ,GAEZ,KAAOtC,KAAKG,MAAQH,KAAKC,KAAKhB,QAK7B,GAJA2D,EAAO5C,KAAKI,KAIRwC,IAASlE,EAAKmE,aAAeD,IAASlE,EAAKoE,WAC9C9C,KAAKG,aAIL,GAAIsB,EAAOzB,KAAK+C,mBACfT,EAAMU,KAAKvB,QAIP,GAAIzB,KAAKG,MAAQH,KAAKC,KAAKhB,OAAQ,CACvC,GAAI2D,IAASD,EACZ,MAED3C,KAAKkB,WAAW,eAAiBlB,KAAKN,KAAO,IAC9C,CAIF,OAAO4C,CACR,CAMAS,mBACC,MAAMtB,EAAOzB,KAAK8B,WAAW,sBAAwB9B,KAAKiD,yBAG1D,OAFAjD,KAAKiC,eAEEjC,KAAKuB,QAAQ,mBAAoBE,EACzC,CASAyB,iBACClD,KAAKiC,eACL,IAAIkB,EAAWnD,KAAKC,KAAKmD,OAAOpD,KAAKG,MAAOzB,EAAKW,eAC7CgE,EAASF,EAASlE,OAEtB,KAAOoE,EAAS,GAAG,CAIlB,GAAI3E,EAAKY,WAAWjB,eAAe8E,MACjCzE,EAAKsC,kBAAkBhB,KAAKI,OAC5BJ,KAAKG,MAAQgD,EAASlE,OAASe,KAAKC,KAAKhB,SAAWP,EAAK4E,iBAAiBtD,KAAKC,KAAKI,WAAWL,KAAKG,MAAQgD,EAASlE,UAGtH,OADAe,KAAKG,OAASkD,EACPF,EAERA,EAAWA,EAASC,OAAO,IAAKC,EACjC,CACA,OAAO,CACR,CAOAJ,yBACC,IAAIxB,EAAM8B,EAAMC,EAAMC,EAAOC,EAAWC,EAAMC,EAAOC,EAAGC,EAMxD,GADAH,EAAO3D,KAAK+D,eACPJ,EACJ,OAAOA,EAKR,GAHAJ,EAAOvD,KAAKkD,kBAGPK,EACJ,OAAOI,EAgBR,IAXAD,EAAY,CAAEjF,MAAO8E,EAAMC,KAAM9E,EAAKsF,iBAAiBT,GAAOU,QAASvF,EAAKa,kBAAkBwB,IAAIwC,IAElGK,EAAQ5D,KAAK+D,cAERH,GACJ5D,KAAKkB,WAAW,6BAA+BqC,GAGhDE,EAAQ,CAACE,EAAMD,EAAWE,GAGlBL,EAAOvD,KAAKkD,kBAAmB,CAGtC,GAFAM,EAAO9E,EAAKsF,iBAAiBT,GAEhB,IAATC,EAAY,CACfxD,KAAKG,OAASoD,EAAKtE,OACnB,KACD,CAEAyE,EAAY,CAAEjF,MAAO8E,EAAMC,OAAMS,QAASvF,EAAKa,kBAAkBwB,IAAIwC,IAErEO,EAAWP,EAGX,MAAMW,EAAcC,GAAQT,EAAUO,SAAWE,EAAKF,QACnDT,EAAOW,EAAKX,KACZA,GAAQW,EAAKX,KAChB,KAAQC,EAAMxE,OAAS,GAAMiF,EAAYT,EAAMA,EAAMxE,OAAS,KAC7D2E,EAAQH,EAAMW,MACdb,EAAOE,EAAMW,MAAM3F,MACnBkF,EAAOF,EAAMW,MACb3C,EAAO,CACNe,KAAM9D,EAAK2F,WACXC,SAAUf,EACVI,OACAC,SAEDH,EAAMT,KAAKvB,GAGZA,EAAOzB,KAAK+D,cAEPtC,GACJzB,KAAKkB,WAAW,6BAA+B4C,GAGhDL,EAAMT,KAAKU,EAAWjC,EACvB,CAKA,IAHAoC,EAAIJ,EAAMxE,OAAS,EACnBwC,EAAOgC,EAAMI,GAENA,EAAI,GACVpC,EAAO,CACNe,KAAM9D,EAAK2F,WACXC,SAAUb,EAAMI,EAAI,GAAGpF,MACvBkF,KAAMF,EAAMI,EAAI,GAChBD,MAAOnC,GAERoC,GAAK,EAGN,OAAOpC,CACR,CAOAsC,cACC,IAAIpD,EAAIwC,EAAUE,EAAQ5B,EAI1B,GAFAzB,KAAKiC,eACLR,EAAOzB,KAAK8B,WAAW,gBACnBL,EACH,OAAOzB,KAAKuB,QAAQ,cAAeE,GAKpC,GAFAd,EAAKX,KAAKI,KAEN1B,EAAKuC,eAAeN,IAAOA,IAAOjC,EAAK6F,YAE1C,OAAOvE,KAAKwE,uBAGb,GAAI7D,IAAOjC,EAAK+F,aAAe9D,IAAOjC,EAAKgG,YAE1CjD,EAAOzB,KAAK2E,2BAER,GAAIhE,IAAOjC,EAAKkG,YACpBnD,EAAOzB,KAAK6E,kBAER,CAIJ,IAHA1B,EAAWnD,KAAKC,KAAKmD,OAAOpD,KAAKG,MAAOzB,EAAKI,cAC7CuE,EAASF,EAASlE,OAEXoE,EAAS,GAAG,CAIlB,GAAI3E,EAAKQ,UAAUb,eAAe8E,MAChCzE,EAAKsC,kBAAkBhB,KAAKI,OAC5BJ,KAAKG,MAAQgD,EAASlE,OAASe,KAAKC,KAAKhB,SAAWP,EAAK4E,iBAAiBtD,KAAKC,KAAKI,WAAWL,KAAKG,MAAQgD,EAASlE,UACpH,CACFe,KAAKG,OAASkD,EACd,MAAMyB,EAAW9E,KAAK+D,cAItB,OAHKe,GACJ9E,KAAKkB,WAAW,4BAEVlB,KAAKuB,QAAQ,cAAe,CAClCiB,KAAM9D,EAAKqG,UACXT,SAAUnB,EACV2B,WACAE,QAAQ,GAEV,CAEA7B,EAAWA,EAASC,OAAO,IAAKC,EACjC,CAEI3E,EAAKsC,kBAAkBL,IAC1Bc,EAAOzB,KAAKiF,mBACRvG,EAAKoB,SAASzB,eAAeoD,EAAKD,MACrCC,EAAO,CACNe,KAAM9D,EAAKwG,QACXzG,MAAOC,EAAKoB,SAAS2B,EAAKD,MAC1B2D,IAAK1D,EAAKD,MAGHC,EAAKD,OAAS9C,EAAK0G,WAC3B3D,EAAO,CAAEe,KAAM9D,EAAK2G,YAGb1E,IAAOjC,EAAK4G,cACpB7D,EAAOzB,KAAKuF,cAEd,CAEA,OAAK9D,GAILA,EAAOzB,KAAKwF,oBAAoB/D,GACzBzB,KAAKuB,QAAQ,cAAeE,IAJ3BzB,KAAKuB,QAAQ,eAAe,EAKrC,CAUAiE,oBAAoB/D,GACnBzB,KAAKiC,eAEL,IAAItB,EAAKX,KAAKI,KACd,KAAOO,IAAOjC,EAAK6F,aAAe5D,IAAOjC,EAAKkG,aAAejE,IAAOjC,EAAK4G,aAAe3E,IAAOjC,EAAK+G,aAAa,CAChH,IAAIC,EACJ,GAAI/E,IAAOjC,EAAK+G,YAAa,CAC5B,GAAIzF,KAAKC,KAAKI,WAAWL,KAAKG,MAAQ,KAAOzB,EAAK6F,YACjD,MAEDmB,GAAW,EACX1F,KAAKG,OAAS,EACdH,KAAKiC,eACLtB,EAAKX,KAAKI,IACX,CACAJ,KAAKG,QAEDQ,IAAOjC,EAAKkG,cACfnD,EAAO,CACNe,KAAM9D,EAAKiH,WACXC,UAAU,EACVC,OAAQpE,EACRqE,SAAU9F,KAAK+C,qBAEN+C,UACT9F,KAAKkB,WAAW,eAAiBlB,KAAKN,KAAO,KAE9CM,KAAKiC,eACLtB,EAAKX,KAAKI,KACNO,IAAOjC,EAAKqH,aACf/F,KAAKkB,WAAW,cAEjBlB,KAAKG,SAEGQ,IAAOjC,EAAK4G,YAEpB7D,EAAO,CACNe,KAAM9D,EAAKsH,SACX,UAAahG,KAAKiG,gBAAgBvH,EAAKwH,aACvCC,OAAQ1E,IAGDd,IAAOjC,EAAK6F,aAAemB,KAC/BA,GACH1F,KAAKG,QAENH,KAAKiC,eACLR,EAAO,CACNe,KAAM9D,EAAKiH,WACXC,UAAU,EACVC,OAAQpE,EACRqE,SAAU9F,KAAKiF,qBAIbS,IACHjE,EAAKiE,UAAW,GAGjB1F,KAAKiC,eACLtB,EAAKX,KAAKI,IACX,CAEA,OAAOqB,CACR,CAOA+C,uBACC,IAAiB7D,EAAIyF,EAAjBC,EAAS,GAEb,KAAO3H,EAAKuC,eAAejB,KAAKI,OAC/BiG,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,SAGjC,GAAIH,KAAKI,OAAS1B,EAAK6F,YAGtB,IAFA8B,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,SAEzBzB,EAAKuC,eAAejB,KAAKI,OAC/BiG,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,SAMlC,GAFAQ,EAAKX,KAAKN,KAEC,MAAPiB,GAAqB,MAAPA,EAAY,CAQ7B,IAPA0F,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,SAChCQ,EAAKX,KAAKN,KAEC,MAAPiB,GAAqB,MAAPA,IACjB0F,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,UAG1BzB,EAAKuC,eAAejB,KAAKI,OAC/BiG,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,SAG5BzB,EAAKuC,eAAejB,KAAKC,KAAKI,WAAWL,KAAKG,MAAQ,KAC1DH,KAAKkB,WAAW,sBAAwBmF,EAASrG,KAAKN,KAAO,IAE/D,CAaA,OAXA0G,EAASpG,KAAKI,KAGV1B,EAAKsC,kBAAkBoF,GAC1BpG,KAAKkB,WAAW,8CACfmF,EAASrG,KAAKN,KAAO,MAEd0G,IAAW1H,EAAK6F,aAAkC,IAAlB8B,EAAOpH,QAAgBoH,EAAOhG,WAAW,KAAO3B,EAAK6F,cAC7FvE,KAAKkB,WAAW,qBAGV,CACNsB,KAAM9D,EAAKwG,QACXzG,MAAO6H,WAAWD,GAClBlB,IAAKkB,EAEP,CAOA1B,sBACC,IAAI4B,EAAM,GACV,MAAMC,EAAaxG,KAAKG,MAClBsG,EAAQzG,KAAKC,KAAKC,OAAOF,KAAKG,SACpC,IAAIuG,GAAS,EAEb,KAAO1G,KAAKG,MAAQH,KAAKC,KAAKhB,QAAQ,CACrC,IAAI0B,EAAKX,KAAKC,KAAKC,OAAOF,KAAKG,SAE/B,GAAIQ,IAAO8F,EAAO,CACjBC,GAAS,EACT,KACD,CACK,GAAW,OAAP/F,EAIR,OAFAA,EAAKX,KAAKC,KAAKC,OAAOF,KAAKG,SAEnBQ,GACP,IAAK,IAAK4F,GAAO,KAAM,MACvB,IAAK,IAAKA,GAAO,KAAM,MACvB,IAAK,IAAKA,GAAO,KAAM,MACvB,IAAK,IAAKA,GAAO,KAAM,MACvB,IAAK,IAAKA,GAAO,KAAM,MACvB,IAAK,IAAKA,GAAO,KAAQ,MACzB,QAAUA,GAAO5F,OAIlB4F,GAAO5F,CAET,CAMA,OAJK+F,GACJ1G,KAAKkB,WAAW,yBAA2BqF,EAAM,KAG3C,CACN/D,KAAM9D,EAAKwG,QACXzG,MAAO8H,EACPpB,IAAKnF,KAAKC,KAAK0G,UAAUH,EAAYxG,KAAKG,OAE5C,CASA8E,mBACC,IAAItE,EAAKX,KAAKI,KAAMwG,EAAQ5G,KAAKG,MASjC,IAPIzB,EAAKsC,kBAAkBL,GAC1BX,KAAKG,QAGLH,KAAKkB,WAAW,cAAgBlB,KAAKN,MAG/BM,KAAKG,MAAQH,KAAKC,KAAKhB,SAC7B0B,EAAKX,KAAKI,KAEN1B,EAAK4E,iBAAiB3C,KACzBX,KAAKG,QAMP,MAAO,CACNqC,KAAM9D,EAAKmI,WACXrF,KAAMxB,KAAKC,KAAK6G,MAAMF,EAAO5G,KAAKG,OAEpC,CAWA8F,gBAAgBc,GACf,MAAMC,EAAO,GACb,IAAIN,GAAS,EACTO,EAAkB,EAEtB,KAAOjH,KAAKG,MAAQH,KAAKC,KAAKhB,QAAQ,CACrCe,KAAKiC,eACL,IAAIW,EAAO5C,KAAKI,KAEhB,GAAIwC,IAASmE,EAAa,CACzBL,GAAS,EACT1G,KAAKG,QAED4G,IAAgBrI,EAAKwH,aAAee,GAAmBA,GAAmBD,EAAK/H,QAClFe,KAAKkB,WAAW,oBAAsBL,OAAOC,aAAaiG,IAG3D,KACD,CACK,GAAInE,IAASlE,EAAKoE,YAItB,GAHA9C,KAAKG,QACL8G,IAEIA,IAAoBD,EAAK/H,OAC5B,GAAI8H,IAAgBrI,EAAKwH,YACxBlG,KAAKkB,WAAW,2BAEZ,GAAI6F,IAAgBrI,EAAKqH,YAC7B,IAAK,IAAImB,EAAMF,EAAK/H,OAAQiI,EAAMD,EAAiBC,IAClDF,EAAKhE,KAAK,WAKT,GAAIgE,EAAK/H,SAAWgI,GAAuC,IAApBA,EAE3CjH,KAAKkB,WAAW,sBAEZ,CACJ,MAAMO,EAAOzB,KAAK+C,mBAEbtB,GAAQA,EAAKe,OAAS9D,EAAK+D,UAC/BzC,KAAKkB,WAAW,kBAGjB8F,EAAKhE,KAAKvB,EACX,CACD,CAMA,OAJKiF,GACJ1G,KAAKkB,WAAW,YAAcL,OAAOC,aAAaiG,IAG5CC,CACR,CAWAzB,cACCvF,KAAKG,QACL,IAAImC,EAAQtC,KAAKuC,kBAAkB7D,EAAKwH,aACxC,GAAIlG,KAAKI,OAAS1B,EAAKwH,YAEtB,OADAlG,KAAKG,QACgB,IAAjBmC,EAAMrD,OACFqD,EAAM,KAEJA,EAAMrD,QAIR,CACNuD,KAAM9D,EAAKyI,aACXC,YAAa9E,GAKftC,KAAKkB,WAAW,aAElB,CAQA2D,cAGC,OAFA7E,KAAKG,QAEE,CACNqC,KAAM9D,EAAK2I,UACXC,SAAUtH,KAAKiG,gBAAgBvH,EAAKqH,aAEtC,EAID,MAAMrE,EAAQ,IA58Bd,MAmBClC,IAAIgC,EAAMQ,EAAUuF,GACnB,GAA2B,iBAAhBC,UAAU,GAEpB,IAAK,IAAIhG,KAAQgG,UAAU,GAC1BxH,KAAKR,IAAIgC,EAAMgG,UAAU,GAAGhG,GAAOgG,UAAU,SAI7CC,MAAMC,QAAQlG,GAAQA,EAAO,CAACA,IAAOmG,SAAQ,SAAUnG,GACvDxB,KAAKwB,GAAQxB,KAAKwB,IAAS,GAEvBQ,GACHhC,KAAKwB,GAAM+F,EAAQ,UAAY,QAAQvF,EAEzC,GAAGhC,KAEL,CAWA6B,IAAIL,EAAMG,GACT3B,KAAKwB,GAAQxB,KAAKwB,IAAS,GAC3BxB,KAAKwB,GAAMmG,SAAQ,SAAU3F,GAC5BA,EAAS1D,KAAKqD,GAAOA,EAAIC,QAAUD,EAAIC,QAAUD,EAAKA,EACvD,GACD,GA05BD7D,OAAO8J,OAAOlJ,EAAM,CACnBgD,QACAmG,QAAS,IAt5BV,MACCvH,YAAYwH,GACX9H,KAAK8H,KAAOA,EACZ9H,KAAK+H,WAAa,CAAC,CACpB,CAeAC,YAAYH,GACXA,EAAQF,SAASM,IAChB,GAAsB,iBAAXA,IAAwBA,EAAOzG,OAASyG,EAAOC,KACzD,MAAM,IAAI7G,MAAM,8BAEbrB,KAAK+H,WAAWE,EAAOzG,QAI3ByG,EAAOC,KAAKlI,KAAK8H,MACjB9H,KAAK+H,WAAWE,EAAOzG,MAAQyG,EAAM,GAEvC,GAu3BqBvJ,GAMrB+D,SAAiB,WACjB0E,aAAiB,qBACjBN,WAAiB,aACjBlB,WAAiB,mBACjBT,QAAiB,UACjBG,SAAiB,iBACjBW,SAAiB,iBACjBjB,UAAiB,kBACjBV,WAAiB,mBACjBgD,UAAiB,kBAEjBlF,SAAa,EACbC,QAAa,GACbC,QAAa,GACbH,WAAa,GACbqC,YAAa,GACbzB,WAAa,GACb2B,YAAa,GACbC,YAAa,GACbY,YAAa,GACbY,YAAa,GACbtB,YAAa,GACbmB,YAAa,GACbN,YAAa,GACb5C,YAAa,GACbsF,WAAa,GAObjJ,UAAW,CACV,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,GAMNI,WAAY,CACX,KAAM,EAAG,KAAM,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EACvC,KAAM,EAAG,KAAM,EAAG,MAAO,EAAG,MAAO,EACnC,IAAK,EAAG,IAAK,EAAG,KAAM,EAAG,KAAM,EAC/B,KAAM,EAAG,KAAM,EAAG,MAAO,EACzB,IAAK,EAAG,IAAK,EACb,IAAK,GAAI,IAAK,GAAI,IAAK,IAIxBC,kBAAmB,IAAI6I,IAGvBzI,4BAA6B,IAAIyI,IAAI,CAAC,IAAK,MAK3CtI,SAAU,CACT,MAAQ,EACR,OAAS,EACT,KAAQ,MAITsF,SAAU,SAEX1G,EAAKI,aAAeJ,EAAKqB,aAAarB,EAAKQ,WAC3CR,EAAKW,cAAgBX,EAAKqB,aAAarB,EAAKY,YAG5C,MAAMwI,EAAO7H,GAAQ,IAAKvB,EAAKuB,GAAOM,QAChC8H,EAAgBvK,OAAOwK,oBAAoB,SACjDxK,OAAOwK,oBAAoB5J,GACzB6J,QAAOpK,IAASkK,EAAcG,SAASrK,SAAwBsK,IAAfX,EAAK3J,KACrDwJ,SAASe,IACTZ,EAAKY,GAAKhK,EAAKgK,EAAE,IAEnBZ,EAAKpJ,KAAOA,EAIZ,IAAIiK,EAAU,CACbnH,KAAM,UAEN0G,KAAKJ,GAEJA,EAAKpG,MAAMlC,IAAI,oBAAoB,SAAuBmC,GACzD,GAAIA,EAAIF,MAAQzB,KAAKI,OAAS0H,EAAKrC,YAAa,CAC/CzF,KAAKG,QACL,MAAMyI,EAAOjH,EAAIF,KACXoH,EAAa7I,KAAK+C,mBAQxB,GANK8F,GACJ7I,KAAKkB,WAAW,uBAGjBlB,KAAKiC,eAEDjC,KAAKI,OAAS0H,EAAKK,WAAY,CAClCnI,KAAKG,QACL,MAAM2I,EAAY9I,KAAK+C,mBAcvB,GAZK+F,GACJ9I,KAAKkB,WAAW,uBAEjBS,EAAIF,KAAO,CACVe,KA3BkB,wBA4BlBoG,OACAC,aACAC,aAKGF,EAAKtE,UAAYwD,EAAKxI,WAAWsJ,EAAKtE,WAAa,GAAK,CAC3D,IAAIyE,EAAUH,EACd,KAAOG,EAAQnF,MAAMU,UAAYwD,EAAKxI,WAAWyJ,EAAQnF,MAAMU,WAAa,IAC3EyE,EAAUA,EAAQnF,MAEnBjC,EAAIF,KAAKmH,KAAOG,EAAQnF,MACxBmF,EAAQnF,MAAQjC,EAAIF,KACpBE,EAAIF,KAAOmH,CACZ,CACD,MAEC5I,KAAKkB,WAAW,aAElB,CACD,GACD,GAKD4G,EAAKD,QAAQG,SAASW,GCjmCtB,MAAMK,EAAY,0BAElB,IAAI7I,EAAQ,CACXqB,KAAM,QAEN0G,KAAKJ,GAuCJ,SAASmB,EAAuBxH,GAC3BA,IAEH3D,OAAOoL,OAAOzH,GAAMkG,SAASwB,IACxBA,GAAsB,iBAARA,GACjBF,EAAuBE,EACxB,IAGqB,OAAlB1H,EAAK6C,WACR7C,EAAKe,KAAOwG,EACZvH,EAAK2H,OAAS3H,EAAKkC,KAAO,CAAClC,EAAKkC,MAAQ,KACxClC,EAAKiB,KAAOjB,EAAKmC,MACbnC,EAAK2H,QAAU3H,EAAK2H,OAAO,GAAG5G,OAASsF,EAAKX,eAC/C1F,EAAK2H,OAAS3H,EAAK2H,OAAO,GAAGhC,oBAEvB3F,EAAKkC,YACLlC,EAAKmC,aACLnC,EAAK6C,UAGf,CA1DAwD,EAAKuB,YAAY,KAAM,IAAK,GAI5BvB,EAAKpG,MAAMlC,IAAI,qBAAqB,SAA6BmC,GAEhE,GADA3B,KAAKiC,eACDjC,KAAKI,OAAS0H,EAAKxC,YAAa,CACnC,MAAMgE,EAActJ,KAAKG,MAIzB,GAHAH,KAAKG,QAELH,KAAKiC,eACDjC,KAAKI,OAAS0H,EAAK5B,YAAa,CACnClG,KAAKG,QAEL,MAAMoD,EAAOvD,KAAKkD,iBAClB,GAAa,OAATK,EAAe,CAElB,MAAMb,EAAO1C,KAAKiD,yBASlB,OARKP,GACJ1C,KAAKkB,WAAW,6BAA+BqC,QAEhD5B,EAAIF,KAAO,CACVe,KAAMwG,EACNI,OAAQ,KACR1G,QAGF,CACD,CACA1C,KAAKG,MAAQmJ,CACd,CACD,IAEAxB,EAAKpG,MAAMlC,IAAI,oBAAoB,SAAwBmC,GAC1DsH,EAAuBtH,EAAIF,KAC5B,GAwBD,GClEG,EAAQ,CACXD,KAAM,MAEN0G,KAAKJ,GACJA,EAAKyB,WAAW,OAEhBzB,EAAKpG,MAAMlC,IAAI,eAAe,SAAmBmC,GAChD,MAAMF,EAAOE,EAAIF,KACjB,GAAIA,GAA0B,QAAlBA,EAAK6C,SAAoB,CAC/B7C,EAAKqD,UAAa,CAACgD,EAAK9B,SAAU8B,EAAKnC,YAAY6C,SAAS/G,EAAKqD,SAAStC,OAC9ExC,KAAKkB,WAAW,2BAEjBS,EAAIF,KAAOA,EAAKqD,SAGhB,IAAI0E,EAAW7H,EAAIF,KACnB,KAAO+H,EAAShH,OAASsF,EAAKnC,YAC7B6D,EAAShH,OAASsF,EAAK9B,UAAYwD,EAASrD,OAAO3D,OAASsF,EAAKnC,YACjE6D,EAAWA,EAAShH,OAASsF,EAAKnC,WAC/B6D,EAAS3D,OACT2D,EAASrD,OAAON,OAEpB2D,EAAShH,KAAO,eACjB,CACD,GACD,GCtBG,EAAQ,CACXhB,KAAM,UAEN0G,KAAKxJ,GA+CJ,SAAS+K,EAAoBC,GAC5B,MAAgB,MAAZA,GAA+B,MAAZA,GACtB1J,KAAKG,OAAS,EACP,CACN,CAAC,GAAI,IACL,CAAC,GAAI,IACL,CAAC,GAAI,OAGc,MAAZuJ,GAA+B,MAAZA,GAC3B1J,KAAKG,OAAS,EACP,CAAC,CAAC,GAAI,MAEO,MAAZuJ,GAA+B,MAAZA,GAC1BA,GAAW,KAAOA,GAAW,KAC9B1J,KAAKG,OAASuJ,GAAW,IAAM,EAAI,EAC5B,CAAC,CAAC,GAAI,MAEP,IACR,CAOA,SAASC,EAAcD,GACtB,MAAgB,MAAZA,GAA+B,MAAZA,EACf,GAEa,MAAZA,GAA+B,MAAZA,EACpB,EAGD,CACR,CAOA,SAASE,EAA0BxJ,EAAMyJ,GACxC,OA/FgB,KA+FTzJ,GACNyJ,EAAOC,MAAK,EAAEC,EAAK/K,KAASoB,GAAQ2J,GAAO3J,GAAQpB,GACrD,CAMA,SAASgL,EAAarI,GACrB,MAAM6E,EAAaxG,KAAKG,MACxB,IAAIkG,EAAS,GAEb,MAAM4D,EAAe,KACpB,KAAOvL,EAAKuC,eAAejB,KAAKI,OA5GjB,KA4G0BJ,KAAKI,MA5G/B,KA6GVJ,KAAKI,KACRJ,KAAKG,QAGLkG,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,QAElC,EAGD8J,IACIjK,KAAKI,OAAS1B,EAAK6F,cACtB8B,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,SAEhC8J,KAGD,IAAItJ,EAAKX,KAAKN,KACH,MAAPiB,GAAqB,MAAPA,IACjB0F,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,SAChCQ,EAAKX,KAAKN,KAEC,MAAPiB,GAAqB,MAAPA,IACjB0F,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,UAGjC8J,IAEKvL,EAAKuC,eAAejB,KAAKC,KAAKI,WAAWL,KAAKG,MAAQ,KAC1DH,KAAKkB,WAAW,sBAAwBmF,EAASrG,KAAKN,KAAO,MAI/D,MAAM0G,EAASpG,KAAKI,KAGpB,GAAI1B,EAAKsC,kBAAkBoF,GAC1BpG,KAAKkB,WAAW,8CACfmF,EAASrG,KAAKN,KAAO,UAElB,GAAI0G,IAAW1H,EAAK6F,YAMxB,OALI8B,EAAOpH,OAAS,GACnBe,KAAKkB,WAAW,qBAAqBgJ,KAAKC,UAAU,CAAE/D,SAAQC,UAAU,KAAM,WAG/ErG,KAAKG,MAAQqG,GAId7E,EAAIF,KAAO,CACVe,KAAM9D,EAAKwG,QACXzG,MAAO6H,WAAWD,GAClBlB,IAAKnF,KAAKC,KAAK0G,UAAUH,EAAYxG,KAAKG,OAE5C,CA5JAzB,EAAKgD,MAAMlC,IAAI,gBAAgB,SAAsBmC,GACpD,GARgB,KAQZ3B,KAAKI,KAAqB,CAC7B,MAAMoG,EAAaxG,KAAKG,MAClBuJ,EAAU1J,KAAKC,KAAKC,OAAOF,KAAKG,MAAQ,GACxC0J,EAASJ,EAAoBnL,KAAK0B,KAAM0J,GAC9C,IAAKG,EACJ,OAGD,IAAIxD,EAAS,GACb,KAAOuD,EAA0B5J,KAAKI,KAAMyJ,IAhB7B,KAiBV7J,KAAKI,KACRJ,KAAKG,QAGLkG,GAAUrG,KAAKC,KAAKC,OAAOF,KAAKG,SAKlC,GAAIzB,EAAK4E,iBAAiBtD,KAAKI,MAAO,CACrC,GAAI1B,EAAKuC,eAAejB,KAAKI,OAAS1B,EAAKuC,eAAeyI,EAAQrJ,WAAW,IAI5E,OAFAL,KAAKG,MAAQqG,EAAa,OAC1BwD,EAAa1L,KAAK0B,KAAM2B,GAGzB3B,KAAKkB,WAAW,gCACjB,CAEAS,EAAIF,KAAO,CACVe,KAAM9D,EAAKwG,QACXzG,MAAO2L,SAAS/D,EAAQsD,EAAcD,IACtCvE,IAAKnF,KAAKC,KAAK0G,UAAUH,EAAYxG,KAAKG,OAE5C,MACSzB,EAAKuC,eAAejB,KAAKI,OAASJ,KAAKI,OAAS1B,EAAK6F,cAC7DyF,EAAa1L,KAAK0B,KAAM2B,EAE1B,GAsHD,GCjKG,EAAQ,CACXH,KAAM,QAEN0G,KAAKJ,GAEJA,EAAKpG,MAAMlC,IAAI,gBAAgB,SAA4BmC,GAC1D,GATiB,KASb3B,KAAKI,KAAsB,CAC9B,MAAMiK,IAAiBrK,KAAKG,MAE5B,IAAImK,GAAY,EAChB,KAAOtK,KAAKG,MAAQH,KAAKC,KAAKhB,QAAQ,CACrC,GAde,KAcXe,KAAKI,OAAyBkK,EAAW,CAC5C,MAAMC,EAAUvK,KAAKC,KAAK6G,MAAMuD,EAAcrK,KAAKG,OAEnD,IAaI1B,EAbA+L,EAAQ,GACZ,OAASxK,KAAKG,MAAQH,KAAKC,KAAKhB,QAAQ,CACvC,MAAMmB,EAAOJ,KAAKI,KAClB,KAAKA,GAAQ,IAAMA,GAAQ,KACtBA,GAAQ,IAAMA,GAAQ,IACtBA,GAAQ,IAAMA,GAAQ,IAI1B,MAHAoK,GAASxK,KAAKN,IAKhB,CAGA,IACCjB,EAAQ,IAAIgM,OAAOF,EAASC,EAC7B,CACA,MAAOE,GACN1K,KAAKkB,WAAWwJ,EAAEvJ,QACnB,CAUA,OARAQ,EAAIF,KAAO,CACVe,KAAMsF,EAAK5C,QACXzG,QACA0G,IAAKnF,KAAKC,KAAK6G,MAAMuD,EAAe,EAAGrK,KAAKG,QAI7CwB,EAAIF,KAAOzB,KAAKwF,oBAAoB7D,EAAIF,MACjCE,EAAIF,IACZ,CACIzB,KAAKI,OAAS0H,EAAKlD,YACtB0F,GAAY,EAEJA,GAAatK,KAAKI,OAAS0H,EAAK/B,cACxCuE,GAAY,GAEbtK,KAAKG,OArDU,KAqDDH,KAAKI,KAAuB,EAAI,CAC/C,CACAJ,KAAKkB,WAAW,iBACjB,CACD,GACD,GCzDG,EAAQ,CACXM,KAAM,UAEN0G,KAAKJ,GAEJA,EAAKpG,MAAMlC,IAAI,oBAAoB,SAAuBmC,GACzD,GAAIA,EAAIF,MAAQzB,KAAKI,OAAS0H,EAAKrC,YAAa,CAC/CzF,KAAKG,QACL,MAAMyI,EAAOjH,EAAIF,KACXoH,EAAa7I,KAAK+C,mBAQxB,GANK8F,GACJ7I,KAAKkB,WAAW,uBAGjBlB,KAAKiC,eAEDjC,KAAKI,OAAS0H,EAAKK,WAAY,CAClCnI,KAAKG,QACL,MAAM2I,EAAY9I,KAAK+C,mBAcvB,GAZK+F,GACJ9I,KAAKkB,WAAW,uBAEjBS,EAAIF,KAAO,CACVe,KA3BkB,wBA4BlBoG,OACAC,aACAC,aAKGF,EAAKtE,UAAYwD,EAAKxI,WAAWsJ,EAAKtE,WAAa,GAAK,CAC3D,IAAIyE,EAAUH,EACd,KAAOG,EAAQnF,MAAMU,UAAYwD,EAAKxI,WAAWyJ,EAAQnF,MAAMU,WAAa,IAC3EyE,EAAUA,EAAQnF,MAEnBjC,EAAIF,KAAKmH,KAAOG,EAAQnF,MACxBmF,EAAQnF,MAAQjC,EAAIF,KACpBE,EAAIF,KAAOmH,CACZ,CACD,MAEC5I,KAAKkB,WAAW,aAElB,CACD,GACD,GC5CG,EAAQ,CACXM,KAAM,sBAEN0G,KAAKJ,GACJ,SAAS6C,EAAsBhJ,EAAKiJ,GAAe,GAClD,GAXgB,KAWZ5K,KAAKI,KAAqB,CAC7B,MAAMqB,EAAO,CACZe,KAVoB,kBAWpBqI,OAAQ,GACRzD,YAAa,IAEd,IAAI0D,EAAS,GACT3F,EAAM,GACNuB,GAAS,EACb,MAAMzH,EAASe,KAAKC,KAAKhB,OACnB8L,EAAY,IAAMtJ,EAAKoJ,OAAO7H,KAAK,CACxCR,KAlBoB,kBAmBpB/D,MAAO,CACN0G,MACA2F,UAEDE,KAAMtE,IAGP,KAAO1G,KAAKG,MAAQlB,GAAQ,CAC3B,IAAI0B,EAAKX,KAAKC,KAAKC,SAASF,KAAKG,OAEjC,GAAW,MAAPQ,EAYH,OAXAX,KAAKG,OAAS,EACduG,GAAS,EACTqE,IAEApJ,EAAIF,KAAOA,EAEPmJ,IAEFjJ,EAAIF,KAAOzB,KAAKwF,oBAAoB7D,EAAIF,OAGnCE,EAAIF,KAEP,GAAW,MAAPd,GAAmD,MAArCX,KAAKC,KAAKC,OAAOF,KAAKG,MAAQ,GACpDH,KAAKG,OAAS,EACd4K,IACA5F,EAAM,GACN2F,EAAS,GACTrJ,EAAK2F,YAAYpE,QAAQhD,KAAKuC,kBAnDhB,YAoDVvC,KAAKI,MACRJ,KAAKkB,WAAW,oBAGb,GAAW,OAAPP,EAMR,OAJAwE,GAAOxE,EACPA,EAAKX,KAAKC,KAAKC,SAASF,KAAKG,OAC7BgF,GAAOxE,EAECA,GACP,IAAK,IAAKmK,GAAU,KAAM,MAC1B,IAAK,IAAKA,GAAU,KAAM,MAC1B,IAAK,IAAKA,GAAU,KAAM,MAC1B,IAAK,IAAKA,GAAU,KAAM,MAC1B,IAAK,IAAKA,GAAU,KAAM,MAC1B,IAAK,IAAKA,GAAU,KAAQ,MAC5B,QAAUA,GAAUnK,OAIrBmK,GAAUnK,EACVwE,GAAOxE,CAET,CACAX,KAAKkB,WAAW,aACjB,CACD,CAEA4G,EAAKpG,MAAMlC,IAAI,eAAgBmL,GAE/B7C,EAAKpG,MAAMlC,IAAI,eAAe,SAAwCmC,GACrE,IAAKA,EAAIF,KAAKe,OAASsF,EAAKjB,YAAclF,EAAIF,KAAKe,OAASsF,EAAKnC,aArFjD,KAqFgE3F,KAAKI,KAUpF,OATAuB,EAAIF,KAAO,CACVe,KArF8B,2BAsF9ByI,IAAKtJ,EAAIF,KACTyJ,MAAOP,EAAsBQ,KAAKnL,KAA3B2K,CAAiChJ,GAAK,IAI9CA,EAAIF,KAAOzB,KAAKwF,oBAAoB7D,EAAIF,MAEjCE,EAAIF,IAEb,GACD,GClGqB,iB,ipGA4Ff,SAAS2J,EAASC,GACvB,OAAOC,EAAeD,EADuCE,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAA0B,CAAC,EAC3CC,EAC/C,CAoEO,SAAeC,EAAcJ,G,OAAdI,EAAAA,MAAAA,KAAAA,U,UAAAA,I,OAAAA,EAAf,YAA6BJ,G,2CAClC,MAAO,C,EAAAK,EAAoBL,EAD6CE,EAAAA,OAAAA,QAAAA,IAAAA,EAAAA,GAAAA,EAAAA,GAA0B,CAAC,EACjDC,G,GACpD,IAFsBC,EAAAA,MAAAA,KAAAA,U,CAaf,SAASE,EAAkBN,GAChC,OAAOC,EAAeD,EADgDE,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAA0B,CAAC,EACpDK,EAC/C,CAWO,SAASC,EAAuBR,GACrC,OAAOK,EAAoBL,EADgDE,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAA0B,CAAC,EACpDK,EACpD,CAWO,SAASE,EAAiBT,GAC/B,OAAOC,EAAeD,EAD+CE,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAA0B,CAAC,EACnDQ,EAC/C,CAWO,SAASC,EAAsBX,GACpC,OAAOC,EAAeD,EADoDE,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAA0B,CAAC,EACxDQ,EAC/C,CAeO,SAAST,EACdD,G,IACAE,EAAAA,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAA0B,CAAC,EAC3BU,EAAAA,UAAAA,OAAAA,EAAAA,UAAAA,QAAAA,EAEA,KAA0B,iBAAfZ,GAAkD,iBAAfA,GAA4BA,GAAgB,SAAUA,GAClG,KAAM,2BAAsC,OAAXA,EAAW,iEAG1C,MAAOE,IACTA,EAAY,CAAC,GAGf,IAAM3J,EAkZR,SAAkC2J,GAChC,OAAOW,EAAsBX,EAAWY,EAC1C,CApZkBC,CAAyBb,GACnCc,EAASC,EAAsC,iBAAfjB,EAA0BvD,EAAKuD,GAAcA,EAAYzJ,GAC/F,GAAIqK,EAAcI,GAChB,OAAOA,EAEP,KAAM,CACJ7J,KAAM,iBACNrB,QACwB,iBAAfkK,EACH,kBAA6B,OAAXA,EAAW,mCAC7B,gDAGZ,CAeO,SAAeK,EACpBL,G,OADoBK,EAAAA,MAAAA,KAAAA,U,UAAAA,I,OAAAA,EAAf,YACLL,G,IACAE,EACAU,EAYMrK,E,uCAVN,OAHA2J,EAAAA,EAAAA,OAAAA,QAAAA,IAAAA,EAAAA,GAAAA,EAAAA,GAA0B,CAAC,EAC3BU,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,QAAAA,EAE0B,iBAAfZ,GAAkD,iBAAfA,GAA4BA,GAAgB,SAAUA,GAMhG,MAAOE,IACTA,EAAY,CAAC,GAGT3J,EA2WR,SAAmC2J,GACjC,OAAOW,EAAsBX,EAAWgB,EAC1C,CA7WkBC,CAA0BjB,GACnC,C,EAAAkB,QAAQC,QAAQJ,EAAsC,iBAAfjB,EAA0BvD,EAAKuD,GAAcA,EAAYzJ,IAAU+K,MAC/G,SAACN,GACC,GAAIJ,EAAcI,GAChB,OAAOA,EAEP,KAAM,CACJ7J,KAAM,iBACNrB,QACwB,iBAAfkK,EACH,kBAA6B,OAAXA,EAAW,mCAC7B,gDAGZ,MAvBO,C,EAAAoB,QAAQG,OACb,2BAAsC,OAAXvB,EAAW,kE,GAwB5C,IA/BsBK,EAAAA,MAAAA,KAAAA,U,CA8Cf,SAASmB,EAAQxB,GACtB,OAAOvD,EAAKuD,EACd,CAGA,SAASG,EAAqBa,GAC5B,MACoB,iBAAXA,GACW,iBAAXA,GACW,kBAAXA,GAFP,MAGOA,GAEPA,EAAAA,EAAkBS,KAEtB,CAEA,SAASlB,EAAqBS,GAC5B,MAAyB,kBAAXA,CAChB,CAEA,SAASN,EAAoBM,GAC3B,MAAyB,iBAAXA,CAChB,CAMA,SAASC,EAAgBjB,EAA6BzJ,GACpD,OAAQyJ,EAAW7I,MACjB,IAAK,kBACH,OA2CN,SAA8B6I,EAAkCzJ,GAC9D,IAAMnD,EAAQ6N,EAAgBjB,EAAWvG,SAAUlD,GAEnD,OAAQyJ,EAAW/G,UACjB,IAAK,IACH,OAAQ7F,EACV,IAAK,IACH,OAAQA,EACV,IAAK,IACH,OAAQA,EACV,IAAK,IACH,OAAQA,EACV,QACE,KAAM,mDAAuE,OAApB4M,EAAW/G,SAAS,MAEnF,CA1DayI,CAAqB1B,EAAoCzJ,GAClE,IAAK,mBACH,OA0DN,SAA+ByJ,EAAmCzJ,GAChE,IAAI+B,EAAO2I,EAAgBjB,EAAW1H,KAAM/B,GACxCgC,EAAQ0I,EAAgBjB,EAAWzH,MAAOhC,GAE9C,OAAQyJ,EAAW/G,UACjB,IAAK,IACH,OAAOX,EAAOC,EAChB,IAAK,IACH,OAAOD,EAAOC,EAChB,IAAK,IACH,OAAOD,EAAOC,EAChB,IAAK,IACH,OAAOD,EAAOC,EAChB,IAAK,IACH,OAAOD,EAAOC,EAChB,IAAK,KACH,OAAOD,KAAAA,IAAAA,EAAQC,GACjB,IAAK,KACH,OAAOD,GAAQC,EACjB,IAAK,MACH,OAAOD,IAASC,EAClB,IAAK,KACH,OAAOD,GAAQC,EACjB,IAAK,MACH,OAAOD,IAASC,EAClB,IAAK,IACH,OAAOD,EAAOC,EAChB,IAAK,KACH,OAAOD,GAAQC,EACjB,IAAK,IACH,OAAOD,EAAOC,EAChB,IAAK,KACH,OAAOD,GAAQC,EACjB,IAAK,KACH,OAAOD,KAAQC,EACjB,IAAK,KACH,OAAOD,GAAQC,EACjB,IAAK,KACH,OAAOD,GAAQC,EACjB,IAAK,KACH,OAAOD,QAAAA,EAAQC,EACjB,QACE,KAAM,mDAAuE,OAApByH,EAAW/G,SAAS,cAEnF,CAtGa0I,CAAsB3B,EAAqCzJ,GACpE,IAAK,wBACH,OAsGN,SAAoCyJ,EAAwCzJ,GAC1E,IAAMgH,EAAO0D,EAAgBjB,EAAWzC,KAAMhH,GAC9C,OAAc0K,EAAP1D,EAAuByC,EAAWxC,WAAuCwC,EAAWvC,UAAtClH,EACvD,CAzGaqL,CAA2B5B,EAA0CzJ,GAC9E,IAAK,iBACH,OAyGN,SAA6ByJ,EAAiCzJ,G,IACjDyJ,EAAPrE,EAA2B,QAApBqE,EAAAA,EAAW7D,iBAAX6D,IAAAA,OAAAA,EAAAA,EAAsB5K,IAAIyM,EAAyBtL,IAC1DuE,EAASmG,EAAgBjB,EAAWlF,OAAQvE,GAEhD,IAAKuE,EACH,KAAM,qBAAuC,OAAlBkF,EAAWlF,OAAO,+BACxC,IAAMA,EAAAA,EAAkBgH,UAC7B,KAAM,GAAqB,OAAlB9B,EAAWlF,OAAO,sBAG7B,OAAOA,EAAAA,WAAAA,EAAO,EAAGa,GACnB,CApHaoG,CAAoB/B,EAAmCzJ,GAChE,IAAK,0BACH,OAoHN,SAAsCyJ,EAA6BzJ,G,IAE/DyJ,EAAAA,EAyBKzJ,EA1BDwH,EAQJ,QAPAiC,EAAiB,QAAjBA,EAAAA,EAAWjC,cAAXiC,IAAAA,OAAAA,EAAAA,EAAmB5K,KAAI,SAAC4M,GACtB,GACO,eADCA,EAAE7K,KAEN,OAAO,EAAuBhB,KAE9B,KAAM,mCAA0C,OAAP6L,EAAE7K,KAEjD,WAPA6I,IAAAA,EAAAA,EAOM,GAER,OAAO,WAAU,sDAAGiC,EAAH,gBACf,GAAIA,EAAKrO,OAASmK,EAAOnK,OACvB,KAAM,wBAAiE,OAAzCmK,EAAOtC,MAAMwG,EAAKrO,QAAS,GAAGsO,KAAK,MAAM,sBAGzE,IAAMC,EAAO1P,OAAO2P,YAClBrE,EAAOsE,QAAO,SAACC,EAAyCN,EAAGO,GACzD,IAAMzE,EAAMmE,EAAKM,GAIjB,OAHIC,EAAoB1E,IACtBwE,EAAI3K,KAAK,CAACqK,EAAGlE,IAERwE,CACT,GAAG,KAGL,OAAOrB,EAAgBjB,EAAW3I,KAAMd,EAAQkM,aAAaN,GAC9D,EAACrC,KAAoB,QAAfvJ,EAAAA,EAAQmM,eAARnM,IAAAA,EAAAA,EAAmB,KAC5B,CAhJaoM,CAA6B3C,EAA+BzJ,GACrE,IAAK,mBACH,OAgJN,SAA+ByJ,EAAmCzJ,GAChE,IAAI1D,EAAMoO,EAAgBjB,EAAWxF,OAAQjE,GAE7C,QAAY6G,IAARvK,EACF,OAAQmN,EAAWxF,OAAOrD,MACxB,IAAK,aACH,IAAIyL,EAAaC,EAAoB7C,EAAWxF,OAAQjE,GACxD,MAAMuM,eAAe,mBAA8B,OAAXF,EAAW,oBAErD,IAAK,mBACH,IAAIG,EAAeF,EAAoB7C,EAAWvF,SAAUlE,GAC5D,MAAMyM,UAAU,4DAAyE,OAAbD,EAAa,OAE3F,QACE,KAAM,oDAA2E,OAAvB/C,EAAWxF,OAAOrD,KAAK,UAIvF,IAaI6J,EAbAiC,EAASpQ,EACb,GAAmB,iBAARA,EACToQ,EAASzN,OAAOzC,eACX,GAAmB,iBAARF,EAChBoQ,EAASC,OAAOnQ,eACX,GAAmB,mBAARF,QAEX,GAAmB,iBAARA,EAChB,KAAM,gEAA2E,YAAJA,IAAAA,EAAAA,Y,2FAAP,CAAOA,IAM/E,OAHA0D,EAAQmM,QAAUO,EAGVjD,EAAWvF,SAAStD,MAC1B,IAAK,aACL,IAAK,mBACH6J,EAASC,EAAgBjB,EAAWvF,SAAUlE,GAC9C,MACF,QACE,IAAMkE,EAAWwG,EAAgBjB,EAAWvF,SAAUlE,GACtD,QAAwB,IAAbkE,EACT,KAAM,CAAEtD,KAAM,0BAA2BrB,QAAS,mDAEpDqN,EAAqB1I,GACrBuG,EAASnO,EAAI4H,GAIjB,MAAsB,mBAAXuG,EACFA,EAAOlB,KAAKjN,GAGdmO,CACT,CApMaoC,CAAsBpD,EAAqCzJ,GACpE,IAAK,kBACH,OAoMN,SAA8ByJ,EAAkCzJ,G,IACvDyJ,EAAP,OAA0B,QAAnBA,EAAAA,EAAW/D,gBAAX+D,IAAAA,OAAAA,EAAAA,EAAqB5K,IAAIyM,EAAyBtL,GAC3D,CAtMa8M,CAAqBrD,EAAoCzJ,GAClE,IAAK,qBACH,OAsMN,SAAiCyJ,EAAqCzJ,GACpE,IAAMyK,EAAShB,EAAWjE,YAAY3G,IAAIyM,EAAyBtL,IACnE,OAAOyK,EAAOA,EAAOpN,OAAS,EAChC,CAzMa0P,CAAwBtD,EAAuCzJ,GACxE,IAAK,gBACH,OAyMN,SAA4ByJ,EAA2BzJ,GACrD,IAAIyJ,EAAWlF,QAAqC,eAA3BkF,EAAWlF,OAAO3D,KAczC,MAAK6I,EAAWlF,OAGR,gDAFC,mD,IAdEkF,EAAPrE,EAA2B,QAApBqE,EAAAA,EAAW7D,iBAAX6D,IAAAA,OAAAA,EAAAA,EAAsB5K,IAAIyM,EAAyBtL,IAC9D,OAAQyJ,EAAWlF,OAAO3E,MACxB,IAAK,OAEH,OAAO,EAAIsL,KAAK,EAAG9F,IAErB,IAAK,SAEH,OAAO,EAAIyD,OAAO,EAAGzD,IACvB,QACE,KAAM,qCAA4D,OAAvBqE,EAAWlF,OAAO3E,MASrE,CA9NaoN,CAAmBvD,EAA6BzJ,GACzD,IAAK,UACH,OAyQN,SAAsByJ,EAA0BzJ,GAE9C,OADA4M,EAAqBnD,EAAW5M,OACzB4M,EAAW5M,KACpB,CA5QaoQ,CAAaxD,GACtB,IAAK,aACH,OAiPN,SAAyBA,EAA6BzJ,GACpD4M,EAAqBnD,EAAW7J,MAKhC,IAAMuM,EAAUnM,EAAQmM,QACxB,GAAIA,IAA+B,iBAAZA,GAA2C,mBAAZA,IAA2B1C,EAAW7J,QAAQuM,EAAS,CAC3G,IAAM1B,EAAS0B,EAAQ1C,EAAW7J,MAElC,OADAgN,EAAqBnC,GACdA,CACT,CAAO,GAAIzK,EAAQ2J,WAAaF,EAAW7J,QAAQI,EAAQ2J,UAAW,CACpE,IAAMc,EAASzK,EAAQ2J,UAAUF,EAAW7J,MAE5C,OADAgN,EAAqBnC,GACdA,CACT,CAAO,OAAIhB,EAAW7J,QAAQI,EAAQuK,QAC7BvK,EAAQuK,QAAQd,EAAW7J,WAElC,CAEJ,CArQasN,CAAgBzD,EAA+BzJ,GACxD,IAAK,kBACH,OA0NN,SAA8ByJ,EAA6BzJ,G,IACrByJ,EAElCA,EAFkCA,EAElCA,EAFIjE,EAAmFxF,QAArDyJ,EAAsB,QAAtBA,EAAAA,EAAWjE,mBAAXiE,IAAAA,OAAAA,EAAAA,EAAwB5K,IAAIyM,EAAyBtL,WAArDyJ,IAAAA,EAAAA,EAAkE,GAChGR,EAC4CjJ,QAAhDyJ,EAAiB,QAAjBA,EAAAA,EAAWR,cAAXQ,IAAAA,OAAAA,EAAAA,EAAmB5K,IAAIyM,EAAyBtL,WAAhDyJ,IAAAA,EAAAA,EAA6D,GAC/D,OACER,EACGtC,QAAO,SAACwG,G,OAAOA,EAAE/D,I,IACjBvK,KAAI,SAACsO,G,OAAMA,EAAEtQ,K,IACb8O,KAAK,IACRnG,EAAYmG,KAAK,IACjB1C,EACGtC,QAAO,SAACwG,G,OAAMA,EAAE/D,I,IAChBvK,KAAI,SAACsO,G,OAAMA,EAAEtQ,K,IACb8O,KAAK,GAEZ,CAzOayB,CAAqB3D,EAA+BzJ,GAC7D,IAAK,kBACH,OAyON,SAA8ByJ,EAA6BzJ,GACzD,MAAO,CAAEnD,MAAO4M,EAAWP,OAAQE,KAAMK,EAAWL,KACtD,CA3OaiE,CAAqB5D,GAC9B,QACE,KAAM,6DAA6E,OAAhBA,EAAW7I,KAAK,KAEzF,CAEA,SAAS0L,EAAoB7C,EAA6BzJ,GACxD,OAAQyJ,EAAW7I,MACjB,IAAK,UACH,OAAO,EAA6B/D,MACtC,IAAK,aACH,OAAO,EAAgC+C,KACzC,IAAK,mBACH,OAAO0M,EAAoB,EAAsCpI,SAAUlE,GAC7E,QACE,KAAM,4DAA4E,OAAhByJ,EAAW7I,KAAK,KAExF,CAwQA,SAAS0J,EAAsBX,EAAyB2D,GACtD,IAAMtN,EAAU,CACdmM,aAAStF,EACT8C,UAAW,KAAKA,GAChBY,QAAS,KAAK+C,GACdpB,aAAAA,SAAaN,GAEX,OADAxN,KAAKuL,UAAY,KAAKvL,KAAKuL,UAAciC,GAClCxN,IACT,GAKF,OAFA4B,EAAQkM,aAAa3C,KAAKvJ,GAEnBA,CACT,CAIA,SAASsL,EAAyBtL,GAChC,OAAO,SAAuCyJ,GAC5C,OAAmB,OAAfA,EACK,KAGFiB,EAAgBjB,EAAYzJ,EACrC,CACF,CAEA,SAAS4M,EAAqBhN,GAC5B,GAAa,cAATA,GAAiC,cAATA,GAAiC,gBAATA,EAClD,KAAM,CAAEgB,KAAM,0BAA2BrB,QAAS,qBAA0B,OAALK,EAAK,wBAEhF,CAEA,SAASqM,EAAoB1E,GAC3B,GACiB,iBAARA,GACQ,iBAARA,GACQ,kBAARA,GACQ,mBAARA,GACC,OAARA,GACAA,EAAAA,EAAesB,QAEf,OAAO,EAGT,GAAmB,iBAARtB,EAAkB,C,IACtB,mB,IAAL,QAAK,IAAarL,OAAO0C,KAAK2I,GAAAA,OAAAA,cAAzB,0BACH,IAAK0E,EAAoB1E,EADtB,UAED,OAAO,C,UAFN,Q,aAAA,6B,YAAA,E,MAAA,C,EAML,OAAO,CACT,CAEA,GAAI1B,MAAMC,QAAQyB,GAAM,C,IACjB,mB,IAAL,QAAK,IAAcA,EAAAA,OAAAA,cAAd,0BACH,IAAK0E,EADF,SAED,OAAO,C,UAFN,Q,aAAA,6B,YAAA,E,MAAA,C,EAKP,CAEA,OAAO,CACT,CAtsBA/F,EAAKD,QAAQG,SAASmH,GACtBrH,EAAKD,QAAQG,SAASoH,GACtBtH,EAAKD,QAAQG,SAASqH,GACtBvH,EAAKD,QAAQG,SAASsH,GACtBxH,EAAKD,QAAQG,SAASuH,GACtBzH,EAAKD,QAAQG,SAASwH,GAItB1H,EAAKuB,YAAY,KAAM,GACvBvB,EAAKuB,YAAY,KAAM,GA8rBvB,I,IAAM8C,EAAU,CACd1E,MACAgI,QACAlR,OACAmR,SAAAA,IACAC,IAAAA,IACA5Q,KACAwP,OACAqB,OACA/O,OACA4J,OACAP,KACA2F,SACAC,MACAxJ,WACA8D,SACA2F,UACAC,UACAC,mBACAnS,OAAQ,CACNoS,eAAWzH,EACXb,OAAQ9J,OAAO8J,OAAOuD,KAAK,MAC3BsC,YAAa3P,OAAO2P,YAAYtC,KAAK,MACrCgF,OAAQrS,OAAOqS,OAAOhF,KAAK,MAC3B3K,KAAM1C,OAAO0C,KAAK2K,KAAK,MACvBiF,GAAItS,OAAOsS,GAAGjF,KAAK,MACnBjC,OAAQpL,OAAOoL,OAAOiC,KAAK,QAIzBoB,G,EAAe,KAChBJ,G,WAAAA,CACHM,U","sources":["webpack://@openmrs/esm-expression-evaluator/webpack/bootstrap","webpack://@openmrs/esm-expression-evaluator/webpack/runtime/define property getters","webpack://@openmrs/esm-expression-evaluator/webpack/runtime/hasOwnProperty shorthand","webpack://@openmrs/esm-expression-evaluator/webpack/runtime/make namespace object","webpack://@openmrs/esm-expression-evaluator/../../../node_modules/jsep/dist/jsep.js","webpack://@openmrs/esm-expression-evaluator/../../../node_modules/@jsep-plugin/arrow/dist/index.js","webpack://@openmrs/esm-expression-evaluator/../../../node_modules/@jsep-plugin/new/dist/index.js","webpack://@openmrs/esm-expression-evaluator/../../../node_modules/@jsep-plugin/numbers/dist/index.js","webpack://@openmrs/esm-expression-evaluator/../../../node_modules/@jsep-plugin/regex/dist/index.js","webpack://@openmrs/esm-expression-evaluator/../../../node_modules/@jsep-plugin/ternary/dist/index.js","webpack://@openmrs/esm-expression-evaluator/../../../node_modules/@jsep-plugin/template/dist/index.js","webpack://@openmrs/esm-expression-evaluator/./src/evaluator.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @implements {IHooks}\n */\nclass Hooks {\n\t/**\n\t * @callback HookCallback\n\t * @this {*|Jsep} this\n\t * @param {Jsep} env\n\t * @returns: void\n\t */\n\t/**\n\t * Adds the given callback to the list of callbacks for the given hook.\n\t *\n\t * The callback will be invoked when the hook it is registered for is run.\n\t *\n\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t *\n\t * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\n\t * @param {HookCallback|boolean} callback The callback function which is given environment variables.\n\t * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\n\t * @public\n\t */\n\tadd(name, callback, first) {\n\t\tif (typeof arguments[0] != 'string') {\n\t\t\t// Multiple hook callbacks, keyed by name\n\t\t\tfor (let name in arguments[0]) {\n\t\t\t\tthis.add(name, arguments[0][name], arguments[1]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\n\t\t\t\tthis[name] = this[name] || [];\n\n\t\t\t\tif (callback) {\n\t\t\t\t\tthis[name][first ? 'unshift' : 'push'](callback);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t/**\n\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t *\n\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t *\n\t * @param {string} name The name of the hook.\n\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t * @public\n\t */\n\trun(name, env) {\n\t\tthis[name] = this[name] || [];\n\t\tthis[name].forEach(function (callback) {\n\t\t\tcallback.call(env && env.context ? env.context : env, env);\n\t\t});\n\t}\n}\n\n/**\n * @implements {IPlugins}\n */\nclass Plugins {\n\tconstructor(jsep) {\n\t\tthis.jsep = jsep;\n\t\tthis.registered = {};\n\t}\n\n\t/**\n\t * @callback PluginSetup\n\t * @this {Jsep} jsep\n\t * @returns: void\n\t */\n\t/**\n\t * Adds the given plugin(s) to the registry\n\t *\n\t * @param {object} plugins\n\t * @param {string} plugins.name The name of the plugin\n\t * @param {PluginSetup} plugins.init The init function\n\t * @public\n\t */\n\tregister(...plugins) {\n\t\tplugins.forEach((plugin) => {\n\t\t\tif (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\n\t\t\t\tthrow new Error('Invalid JSEP plugin format');\n\t\t\t}\n\t\t\tif (this.registered[plugin.name]) {\n\t\t\t\t// already registered. Ignore.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tplugin.init(this.jsep);\n\t\t\tthis.registered[plugin.name] = plugin;\n\t\t});\n\t}\n}\n\n//     JavaScript Expression Parser (JSEP) 1.3.9\n\nclass Jsep {\n\t/**\n\t * @returns {string}\n\t */\n\tstatic get version() {\n\t\t// To be filled in by the template\n\t\treturn '1.3.9';\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tstatic toString() {\n\t\treturn 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\n\t};\n\n\t// ==================== CONFIG ================================\n\t/**\n\t * @method addUnaryOp\n\t * @param {string} op_name The name of the unary op to add\n\t * @returns {Jsep}\n\t */\n\tstatic addUnaryOp(op_name) {\n\t\tJsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\n\t\tJsep.unary_ops[op_name] = 1;\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method jsep.addBinaryOp\n\t * @param {string} op_name The name of the binary op to add\n\t * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\n\t * @param {boolean} [isRightAssociative=false] whether operator is right-associative\n\t * @returns {Jsep}\n\t */\n\tstatic addBinaryOp(op_name, precedence, isRightAssociative) {\n\t\tJsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\n\t\tJsep.binary_ops[op_name] = precedence;\n\t\tif (isRightAssociative) {\n\t\t\tJsep.right_associative.add(op_name);\n\t\t}\n\t\telse {\n\t\t\tJsep.right_associative.delete(op_name);\n\t\t}\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method addIdentifierChar\n\t * @param {string} char The additional character to treat as a valid part of an identifier\n\t * @returns {Jsep}\n\t */\n\tstatic addIdentifierChar(char) {\n\t\tJsep.additional_identifier_chars.add(char);\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method addLiteral\n\t * @param {string} literal_name The name of the literal to add\n\t * @param {*} literal_value The value of the literal\n\t * @returns {Jsep}\n\t */\n\tstatic addLiteral(literal_name, literal_value) {\n\t\tJsep.literals[literal_name] = literal_value;\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeUnaryOp\n\t * @param {string} op_name The name of the unary op to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeUnaryOp(op_name) {\n\t\tdelete Jsep.unary_ops[op_name];\n\t\tif (op_name.length === Jsep.max_unop_len) {\n\t\t\tJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\n\t\t}\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllUnaryOps\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllUnaryOps() {\n\t\tJsep.unary_ops = {};\n\t\tJsep.max_unop_len = 0;\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeIdentifierChar\n\t * @param {string} char The additional character to stop treating as a valid part of an identifier\n\t * @returns {Jsep}\n\t */\n\tstatic removeIdentifierChar(char) {\n\t\tJsep.additional_identifier_chars.delete(char);\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeBinaryOp\n\t * @param {string} op_name The name of the binary op to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeBinaryOp(op_name) {\n\t\tdelete Jsep.binary_ops[op_name];\n\n\t\tif (op_name.length === Jsep.max_binop_len) {\n\t\t\tJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\t\t}\n\t\tJsep.right_associative.delete(op_name);\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllBinaryOps\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllBinaryOps() {\n\t\tJsep.binary_ops = {};\n\t\tJsep.max_binop_len = 0;\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeLiteral\n\t * @param {string} literal_name The name of the literal to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeLiteral(literal_name) {\n\t\tdelete Jsep.literals[literal_name];\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllLiterals\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllLiterals() {\n\t\tJsep.literals = {};\n\n\t\treturn Jsep;\n\t}\n\t// ==================== END CONFIG ============================\n\n\n\t/**\n\t * @returns {string}\n\t */\n\tget char() {\n\t\treturn this.expr.charAt(this.index);\n\t}\n\n\t/**\n\t * @returns {number}\n\t */\n\tget code() {\n\t\treturn this.expr.charCodeAt(this.index);\n\t};\n\n\n\t/**\n\t * @param {string} expr a string with the passed in express\n\t * @returns Jsep\n\t */\n\tconstructor(expr) {\n\t\t// `index` stores the character number we are currently at\n\t\t// All of the gobbles below will modify `index` as we move along\n\t\tthis.expr = expr;\n\t\tthis.index = 0;\n\t}\n\n\t/**\n\t * static top-level parser\n\t * @returns {jsep.Expression}\n\t */\n\tstatic parse(expr) {\n\t\treturn (new Jsep(expr)).parse();\n\t}\n\n\t/**\n\t * Get the longest key length of any object\n\t * @param {object} obj\n\t * @returns {number}\n\t */\n\tstatic getMaxKeyLen(obj) {\n\t\treturn Math.max(0, ...Object.keys(obj).map(k => k.length));\n\t}\n\n\t/**\n\t * `ch` is a character code in the next three functions\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isDecimalDigit(ch) {\n\t\treturn (ch >= 48 && ch <= 57); // 0...9\n\t}\n\n\t/**\n\t * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\n\t * @param {string} op_val\n\t * @returns {number}\n\t */\n\tstatic binaryPrecedence(op_val) {\n\t\treturn Jsep.binary_ops[op_val] || 0;\n\t}\n\n\t/**\n\t * Looks for start of identifier\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isIdentifierStart(ch) {\n\t\treturn  (ch >= 65 && ch <= 90) || // A...Z\n\t\t\t(ch >= 97 && ch <= 122) || // a...z\n\t\t\t(ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator\n\t\t\t(Jsep.additional_identifier_chars.has(String.fromCharCode(ch))); // additional characters\n\t}\n\n\t/**\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isIdentifierPart(ch) {\n\t\treturn Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\n\t}\n\n\t/**\n\t * throw error at index of the expression\n\t * @param {string} message\n\t * @throws\n\t */\n\tthrowError(message) {\n\t\tconst error = new Error(message + ' at character ' + this.index);\n\t\terror.index = this.index;\n\t\terror.description = message;\n\t\tthrow error;\n\t}\n\n\t/**\n\t * Run a given hook\n\t * @param {string} name\n\t * @param {jsep.Expression|false} [node]\n\t * @returns {?jsep.Expression}\n\t */\n\trunHook(name, node) {\n\t\tif (Jsep.hooks[name]) {\n\t\t\tconst env = { context: this, node };\n\t\t\tJsep.hooks.run(name, env);\n\t\t\treturn env.node;\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Runs a given hook until one returns a node\n\t * @param {string} name\n\t * @returns {?jsep.Expression}\n\t */\n\tsearchHook(name) {\n\t\tif (Jsep.hooks[name]) {\n\t\t\tconst env = { context: this };\n\t\t\tJsep.hooks[name].find(function (callback) {\n\t\t\t\tcallback.call(env.context, env);\n\t\t\t\treturn env.node;\n\t\t\t});\n\t\t\treturn env.node;\n\t\t}\n\t}\n\n\t/**\n\t * Push `index` up to the next non-space character\n\t */\n\tgobbleSpaces() {\n\t\tlet ch = this.code;\n\t\t// Whitespace\n\t\twhile (ch === Jsep.SPACE_CODE\n\t\t|| ch === Jsep.TAB_CODE\n\t\t|| ch === Jsep.LF_CODE\n\t\t|| ch === Jsep.CR_CODE) {\n\t\t\tch = this.expr.charCodeAt(++this.index);\n\t\t}\n\t\tthis.runHook('gobble-spaces');\n\t}\n\n\t/**\n\t * Top-level method to parse all expressions and returns compound or single node\n\t * @returns {jsep.Expression}\n\t */\n\tparse() {\n\t\tthis.runHook('before-all');\n\t\tconst nodes = this.gobbleExpressions();\n\n\t\t// If there's only one expression just try returning the expression\n\t\tconst node = nodes.length === 1\n\t\t  ? nodes[0]\n\t\t\t: {\n\t\t\t\ttype: Jsep.COMPOUND,\n\t\t\t\tbody: nodes\n\t\t\t};\n\t\treturn this.runHook('after-all', node);\n\t}\n\n\t/**\n\t * top-level parser (but can be reused within as well)\n\t * @param {number} [untilICode]\n\t * @returns {jsep.Expression[]}\n\t */\n\tgobbleExpressions(untilICode) {\n\t\tlet nodes = [], ch_i, node;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tch_i = this.code;\n\n\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\n\t\t\t// separators\n\t\t\tif (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\n\t\t\t\tthis.index++; // ignore separators\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try to gobble each expression individually\n\t\t\t\tif (node = this.gobbleExpression()) {\n\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\n\t\t\t\t\t// the expression passed in probably has too much\n\t\t\t\t}\n\t\t\t\telse if (this.index < this.expr.length) {\n\t\t\t\t\tif (ch_i === untilICode) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.throwError('Unexpected \"' + this.char + '\"');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t/**\n\t * The main parsing function.\n\t * @returns {?jsep.Expression}\n\t */\n\tgobbleExpression() {\n\t\tconst node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\n\t\tthis.gobbleSpaces();\n\n\t\treturn this.runHook('after-expression', node);\n\t}\n\n\t/**\n\t * Search for the operation portion of the string (e.g. `+`, `===`)\n\t * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n\t * and move down from 3 to 2 to 1 character until a matching binary operation is found\n\t * then, return that binary operation\n\t * @returns {string|boolean}\n\t */\n\tgobbleBinaryOp() {\n\t\tthis.gobbleSpaces();\n\t\tlet to_check = this.expr.substr(this.index, Jsep.max_binop_len);\n\t\tlet tc_len = to_check.length;\n\n\t\twhile (tc_len > 0) {\n\t\t\t// Don't accept a binary op when it is an identifier.\n\t\t\t// Binary ops that start with a identifier-valid character must be followed\n\t\t\t// by a non identifier-part valid character\n\t\t\tif (Jsep.binary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t!Jsep.isIdentifierStart(this.code) ||\n\t\t\t\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\n\t\t\t)) {\n\t\t\t\tthis.index += tc_len;\n\t\t\t\treturn to_check;\n\t\t\t}\n\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * This function is responsible for gobbling an individual expression,\n\t * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n\t * @returns {?jsep.BinaryExpression}\n\t */\n\tgobbleBinaryExpression() {\n\t\tlet node, biop, prec, stack, biop_info, left, right, i, cur_biop;\n\n\t\t// First, try to get the leftmost thing\n\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\n\t\t// Don't gobbleBinaryOp without a left-hand-side\n\t\tleft = this.gobbleToken();\n\t\tif (!left) {\n\t\t\treturn left;\n\t\t}\n\t\tbiop = this.gobbleBinaryOp();\n\n\t\t// If there wasn't a binary operator, just return the leftmost node\n\t\tif (!biop) {\n\t\t\treturn left;\n\t\t}\n\n\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\n\t\t// precedence structure\n\t\tbiop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) };\n\n\t\tright = this.gobbleToken();\n\n\t\tif (!right) {\n\t\t\tthis.throwError(\"Expected expression after \" + biop);\n\t\t}\n\n\t\tstack = [left, biop_info, right];\n\n\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\t\twhile ((biop = this.gobbleBinaryOp())) {\n\t\t\tprec = Jsep.binaryPrecedence(biop);\n\n\t\t\tif (prec === 0) {\n\t\t\t\tthis.index -= biop.length;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbiop_info = { value: biop, prec, right_a: Jsep.right_associative.has(biop) };\n\n\t\t\tcur_biop = biop;\n\n\t\t\t// Reduce: make a binary expression from the three topmost entries.\n\t\t\tconst comparePrev = prev => biop_info.right_a && prev.right_a\n\t\t\t\t? prec > prev.prec\n\t\t\t\t: prec <= prev.prec;\n\t\t\twhile ((stack.length > 2) && comparePrev(stack[stack.length - 2])) {\n\t\t\t\tright = stack.pop();\n\t\t\t\tbiop = stack.pop().value;\n\t\t\t\tleft = stack.pop();\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.BINARY_EXP,\n\t\t\t\t\toperator: biop,\n\t\t\t\t\tleft,\n\t\t\t\t\tright\n\t\t\t\t};\n\t\t\t\tstack.push(node);\n\t\t\t}\n\n\t\t\tnode = this.gobbleToken();\n\n\t\t\tif (!node) {\n\t\t\t\tthis.throwError(\"Expected expression after \" + cur_biop);\n\t\t\t}\n\n\t\t\tstack.push(biop_info, node);\n\t\t}\n\n\t\ti = stack.length - 1;\n\t\tnode = stack[i];\n\n\t\twhile (i > 1) {\n\t\t\tnode = {\n\t\t\t\ttype: Jsep.BINARY_EXP,\n\t\t\t\toperator: stack[i - 1].value,\n\t\t\t\tleft: stack[i - 2],\n\t\t\t\tright: node\n\t\t\t};\n\t\t\ti -= 2;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * An individual part of a binary expression:\n\t * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n\t * @returns {boolean|jsep.Expression}\n\t */\n\tgobbleToken() {\n\t\tlet ch, to_check, tc_len, node;\n\n\t\tthis.gobbleSpaces();\n\t\tnode = this.searchHook('gobble-token');\n\t\tif (node) {\n\t\t\treturn this.runHook('after-token', node);\n\t\t}\n\n\t\tch = this.code;\n\n\t\tif (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\n\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\n\t\t\treturn this.gobbleNumericLiteral();\n\t\t}\n\n\t\tif (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\n\t\t\t// Single or double quotes\n\t\t\tnode = this.gobbleStringLiteral();\n\t\t}\n\t\telse if (ch === Jsep.OBRACK_CODE) {\n\t\t\tnode = this.gobbleArray();\n\t\t}\n\t\telse {\n\t\t\tto_check = this.expr.substr(this.index, Jsep.max_unop_len);\n\t\t\ttc_len = to_check.length;\n\n\t\t\twhile (tc_len > 0) {\n\t\t\t\t// Don't accept an unary op when it is an identifier.\n\t\t\t\t// Unary ops that start with a identifier-valid character must be followed\n\t\t\t\t// by a non identifier-part valid character\n\t\t\t\tif (Jsep.unary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t\t!Jsep.isIdentifierStart(this.code) ||\n\t\t\t\t\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\n\t\t\t\t)) {\n\t\t\t\t\tthis.index += tc_len;\n\t\t\t\t\tconst argument = this.gobbleToken();\n\t\t\t\t\tif (!argument) {\n\t\t\t\t\t\tthis.throwError('missing unaryOp argument');\n\t\t\t\t\t}\n\t\t\t\t\treturn this.runHook('after-token', {\n\t\t\t\t\t\ttype: Jsep.UNARY_EXP,\n\t\t\t\t\t\toperator: to_check,\n\t\t\t\t\t\targument,\n\t\t\t\t\t\tprefix: true\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t}\n\n\t\t\tif (Jsep.isIdentifierStart(ch)) {\n\t\t\t\tnode = this.gobbleIdentifier();\n\t\t\t\tif (Jsep.literals.hasOwnProperty(node.name)) {\n\t\t\t\t\tnode = {\n\t\t\t\t\t\ttype: Jsep.LITERAL,\n\t\t\t\t\t\tvalue: Jsep.literals[node.name],\n\t\t\t\t\t\traw: node.name,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse if (node.name === Jsep.this_str) {\n\t\t\t\t\tnode = { type: Jsep.THIS_EXP };\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ch === Jsep.OPAREN_CODE) { // open parenthesis\n\t\t\t\tnode = this.gobbleGroup();\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\treturn this.runHook('after-token', false);\n\t\t}\n\n\t\tnode = this.gobbleTokenProperty(node);\n\t\treturn this.runHook('after-token', node);\n\t}\n\n\t/**\n\t * Gobble properties of of identifiers/strings/arrays/groups.\n\t * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n\t * It also gobbles function calls:\n\t * e.g. `Math.acos(obj.angle)`\n\t * @param {jsep.Expression} node\n\t * @returns {jsep.Expression}\n\t */\n\tgobbleTokenProperty(node) {\n\t\tthis.gobbleSpaces();\n\n\t\tlet ch = this.code;\n\t\twhile (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\n\t\t\tlet optional;\n\t\t\tif (ch === Jsep.QUMARK_CODE) {\n\t\t\t\tif (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toptional = true;\n\t\t\t\tthis.index += 2;\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tch = this.code;\n\t\t\t}\n\t\t\tthis.index++;\n\n\t\t\tif (ch === Jsep.OBRACK_CODE) {\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.MEMBER_EXP,\n\t\t\t\t\tcomputed: true,\n\t\t\t\t\tobject: node,\n\t\t\t\t\tproperty: this.gobbleExpression()\n\t\t\t\t};\n\t\t\t\tif (!node.property) {\n\t\t\t\t\tthis.throwError('Unexpected \"' + this.char + '\"');\n\t\t\t\t}\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tch = this.code;\n\t\t\t\tif (ch !== Jsep.CBRACK_CODE) {\n\t\t\t\t\tthis.throwError('Unclosed [');\n\t\t\t\t}\n\t\t\t\tthis.index++;\n\t\t\t}\n\t\t\telse if (ch === Jsep.OPAREN_CODE) {\n\t\t\t\t// A function call is being made; gobble all the arguments\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.CALL_EXP,\n\t\t\t\t\t'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\n\t\t\t\t\tcallee: node\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (ch === Jsep.PERIOD_CODE || optional) {\n\t\t\t\tif (optional) {\n\t\t\t\t\tthis.index--;\n\t\t\t\t}\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.MEMBER_EXP,\n\t\t\t\t\tcomputed: false,\n\t\t\t\t\tobject: node,\n\t\t\t\t\tproperty: this.gobbleIdentifier(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (optional) {\n\t\t\t\tnode.optional = true;\n\t\t\t} // else leave undefined for compatibility with esprima\n\n\t\t\tthis.gobbleSpaces();\n\t\t\tch = this.code;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n\t * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n\t * @returns {jsep.Literal}\n\t */\n\tgobbleNumericLiteral() {\n\t\tlet number = '', ch, chCode;\n\n\t\twhile (Jsep.isDecimalDigit(this.code)) {\n\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t}\n\n\t\tif (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\n\t\t\tnumber += this.expr.charAt(this.index++);\n\n\t\t\twhile (Jsep.isDecimalDigit(this.code)) {\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\t\t}\n\n\t\tch = this.char;\n\n\t\tif (ch === 'e' || ch === 'E') { // exponent marker\n\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\tch = this.char;\n\n\t\t\tif (ch === '+' || ch === '-') { // exponent sign\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\n\t\t\twhile (Jsep.isDecimalDigit(this.code)) { // exponent itself\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\n\t\t\tif (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ) {\n\t\t\t\tthis.throwError('Expected exponent (' + number + this.char + ')');\n\t\t\t}\n\t\t}\n\n\t\tchCode = this.code;\n\n\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\n\t\tif (Jsep.isIdentifierStart(chCode)) {\n\t\t\tthis.throwError('Variable names cannot start with a number (' +\n\t\t\t\tnumber + this.char + ')');\n\t\t}\n\t\telse if (chCode === Jsep.PERIOD_CODE || (number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE)) {\n\t\t\tthis.throwError('Unexpected period');\n\t\t}\n\n\t\treturn {\n\t\t\ttype: Jsep.LITERAL,\n\t\t\tvalue: parseFloat(number),\n\t\t\traw: number\n\t\t};\n\t}\n\n\t/**\n\t * Parses a string literal, staring with single or double quotes with basic support for escape codes\n\t * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n\t * @returns {jsep.Literal}\n\t */\n\tgobbleStringLiteral() {\n\t\tlet str = '';\n\t\tconst startIndex = this.index;\n\t\tconst quote = this.expr.charAt(this.index++);\n\t\tlet closed = false;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tlet ch = this.expr.charAt(this.index++);\n\n\t\t\tif (ch === quote) {\n\t\t\t\tclosed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ch === '\\\\') {\n\t\t\t\t// Check for all of the common escape codes\n\t\t\t\tch = this.expr.charAt(this.index++);\n\n\t\t\t\tswitch (ch) {\n\t\t\t\t\tcase 'n': str += '\\n'; break;\n\t\t\t\t\tcase 'r': str += '\\r'; break;\n\t\t\t\t\tcase 't': str += '\\t'; break;\n\t\t\t\t\tcase 'b': str += '\\b'; break;\n\t\t\t\t\tcase 'f': str += '\\f'; break;\n\t\t\t\t\tcase 'v': str += '\\x0B'; break;\n\t\t\t\t\tdefault : str += ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstr += ch;\n\t\t\t}\n\t\t}\n\n\t\tif (!closed) {\n\t\t\tthis.throwError('Unclosed quote after \"' + str + '\"');\n\t\t}\n\n\t\treturn {\n\t\t\ttype: Jsep.LITERAL,\n\t\t\tvalue: str,\n\t\t\traw: this.expr.substring(startIndex, this.index),\n\t\t};\n\t}\n\n\t/**\n\t * Gobbles only identifiers\n\t * e.g.: `foo`, `_value`, `$x1`\n\t * Also, this function checks if that identifier is a literal:\n\t * (e.g. `true`, `false`, `null`) or `this`\n\t * @returns {jsep.Identifier}\n\t */\n\tgobbleIdentifier() {\n\t\tlet ch = this.code, start = this.index;\n\n\t\tif (Jsep.isIdentifierStart(ch)) {\n\t\t\tthis.index++;\n\t\t}\n\t\telse {\n\t\t\tthis.throwError('Unexpected ' + this.char);\n\t\t}\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tch = this.code;\n\n\t\t\tif (Jsep.isIdentifierPart(ch)) {\n\t\t\t\tthis.index++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: Jsep.IDENTIFIER,\n\t\t\tname: this.expr.slice(start, this.index),\n\t\t};\n\t}\n\n\t/**\n\t * Gobbles a list of arguments within the context of a function call\n\t * or array literal. This function also assumes that the opening character\n\t * `(` or `[` has already been gobbled, and gobbles expressions and commas\n\t * until the terminator character `)` or `]` is encountered.\n\t * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n\t * @param {number} termination\n\t * @returns {jsep.Expression[]}\n\t */\n\tgobbleArguments(termination) {\n\t\tconst args = [];\n\t\tlet closed = false;\n\t\tlet separator_count = 0;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tthis.gobbleSpaces();\n\t\t\tlet ch_i = this.code;\n\n\t\t\tif (ch_i === termination) { // done parsing\n\t\t\t\tclosed = true;\n\t\t\t\tthis.index++;\n\n\t\t\t\tif (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length){\n\t\t\t\t\tthis.throwError('Unexpected token ' + String.fromCharCode(termination));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ch_i === Jsep.COMMA_CODE) { // between expressions\n\t\t\t\tthis.index++;\n\t\t\t\tseparator_count++;\n\n\t\t\t\tif (separator_count !== args.length) { // missing argument\n\t\t\t\t\tif (termination === Jsep.CPAREN_CODE) {\n\t\t\t\t\t\tthis.throwError('Unexpected token ,');\n\t\t\t\t\t}\n\t\t\t\t\telse if (termination === Jsep.CBRACK_CODE) {\n\t\t\t\t\t\tfor (let arg = args.length; arg < separator_count; arg++) {\n\t\t\t\t\t\t\targs.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (args.length !== separator_count && separator_count !== 0) {\n\t\t\t\t// NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\n\t\t\t\tthis.throwError('Expected comma');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst node = this.gobbleExpression();\n\n\t\t\t\tif (!node || node.type === Jsep.COMPOUND) {\n\t\t\t\t\tthis.throwError('Expected comma');\n\t\t\t\t}\n\n\t\t\t\targs.push(node);\n\t\t\t}\n\t\t}\n\n\t\tif (!closed) {\n\t\t\tthis.throwError('Expected ' + String.fromCharCode(termination));\n\t\t}\n\n\t\treturn args;\n\t}\n\n\t/**\n\t * Responsible for parsing a group of things within parentheses `()`\n\t * that have no identifier in front (so not a function call)\n\t * This function assumes that it needs to gobble the opening parenthesis\n\t * and then tries to gobble everything within that parenthesis, assuming\n\t * that the next thing it should see is the close parenthesis. If not,\n\t * then the expression probably doesn't have a `)`\n\t * @returns {boolean|jsep.Expression}\n\t */\n\tgobbleGroup() {\n\t\tthis.index++;\n\t\tlet nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\n\t\tif (this.code === Jsep.CPAREN_CODE) {\n\t\t\tthis.index++;\n\t\t\tif (nodes.length === 1) {\n\t\t\t\treturn nodes[0];\n\t\t\t}\n\t\t\telse if (!nodes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn {\n\t\t\t\t\ttype: Jsep.SEQUENCE_EXP,\n\t\t\t\t\texpressions: nodes,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.throwError('Unclosed (');\n\t\t}\n\t}\n\n\t/**\n\t * Responsible for parsing Array literals `[1, 2, 3]`\n\t * This function assumes that it needs to gobble the opening bracket\n\t * and then tries to gobble the expressions as arguments.\n\t * @returns {jsep.ArrayExpression}\n\t */\n\tgobbleArray() {\n\t\tthis.index++;\n\n\t\treturn {\n\t\t\ttype: Jsep.ARRAY_EXP,\n\t\t\telements: this.gobbleArguments(Jsep.CBRACK_CODE)\n\t\t};\n\t}\n}\n\n// Static fields:\nconst hooks = new Hooks();\nObject.assign(Jsep, {\n\thooks,\n\tplugins: new Plugins(Jsep),\n\n\t// Node Types\n\t// ----------\n\t// This is the full set of types that any JSEP node can be.\n\t// Store them here to save space when minified\n\tCOMPOUND:        'Compound',\n\tSEQUENCE_EXP:    'SequenceExpression',\n\tIDENTIFIER:      'Identifier',\n\tMEMBER_EXP:      'MemberExpression',\n\tLITERAL:         'Literal',\n\tTHIS_EXP:        'ThisExpression',\n\tCALL_EXP:        'CallExpression',\n\tUNARY_EXP:       'UnaryExpression',\n\tBINARY_EXP:      'BinaryExpression',\n\tARRAY_EXP:       'ArrayExpression',\n\n\tTAB_CODE:    9,\n\tLF_CODE:     10,\n\tCR_CODE:     13,\n\tSPACE_CODE:  32,\n\tPERIOD_CODE: 46, // '.'\n\tCOMMA_CODE:  44, // ','\n\tSQUOTE_CODE: 39, // single quote\n\tDQUOTE_CODE: 34, // double quotes\n\tOPAREN_CODE: 40, // (\n\tCPAREN_CODE: 41, // )\n\tOBRACK_CODE: 91, // [\n\tCBRACK_CODE: 93, // ]\n\tQUMARK_CODE: 63, // ?\n\tSEMCOL_CODE: 59, // ;\n\tCOLON_CODE:  58, // :\n\n\n\t// Operations\n\t// ----------\n\t// Use a quickly-accessible map to store all of the unary operators\n\t// Values are set to `1` (it really doesn't matter)\n\tunary_ops: {\n\t\t'-': 1,\n\t\t'!': 1,\n\t\t'~': 1,\n\t\t'+': 1\n\t},\n\n\t// Also use a map for the binary operations but set their values to their\n\t// binary precedence for quick reference (higher number = higher precedence)\n\t// see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n\tbinary_ops: {\n\t\t'||': 1, '&&': 2, '|': 3, '^': 4, '&': 5,\n\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\n\t\t'<': 7, '>': 7, '<=': 7, '>=': 7,\n\t\t'<<': 8, '>>': 8, '>>>': 8,\n\t\t'+': 9, '-': 9,\n\t\t'*': 10, '/': 10, '%': 10\n\t},\n\n\t// sets specific binary_ops as right-associative\n\tright_associative: new Set(),\n\n\t// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n\tadditional_identifier_chars: new Set(['$', '_']),\n\n\t// Literals\n\t// ----------\n\t// Store the values to return for the various literals we may encounter\n\tliterals: {\n\t\t'true': true,\n\t\t'false': false,\n\t\t'null': null\n\t},\n\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\n\tthis_str: 'this',\n});\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\n// Backward Compatibility:\nconst jsep = expr => (new Jsep(expr)).parse();\nconst stdClassProps = Object.getOwnPropertyNames(class Test{});\nObject.getOwnPropertyNames(Jsep)\n\t.filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined)\n\t.forEach((m) => {\n\t\tjsep[m] = Jsep[m];\n\t});\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\n\nconst CONDITIONAL_EXP = 'ConditionalExpression';\n\nvar ternary = {\n\tname: 'ternary',\n\n\tinit(jsep) {\n\t\t// Ternary expression: test ? consequent : alternate\n\t\tjsep.hooks.add('after-expression', function gobbleTernary(env) {\n\t\t\tif (env.node && this.code === jsep.QUMARK_CODE) {\n\t\t\t\tthis.index++;\n\t\t\t\tconst test = env.node;\n\t\t\t\tconst consequent = this.gobbleExpression();\n\n\t\t\t\tif (!consequent) {\n\t\t\t\t\tthis.throwError('Expected expression');\n\t\t\t\t}\n\n\t\t\t\tthis.gobbleSpaces();\n\n\t\t\t\tif (this.code === jsep.COLON_CODE) {\n\t\t\t\t\tthis.index++;\n\t\t\t\t\tconst alternate = this.gobbleExpression();\n\n\t\t\t\t\tif (!alternate) {\n\t\t\t\t\t\tthis.throwError('Expected expression');\n\t\t\t\t\t}\n\t\t\t\t\tenv.node = {\n\t\t\t\t\t\ttype: CONDITIONAL_EXP,\n\t\t\t\t\t\ttest,\n\t\t\t\t\t\tconsequent,\n\t\t\t\t\t\talternate,\n\t\t\t\t\t};\n\n\t\t\t\t\t// check for operators of higher priority than ternary (i.e. assignment)\n\t\t\t\t\t// jsep sets || at 1, and assignment at 0.9, and conditional should be between them\n\t\t\t\t\tif (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\n\t\t\t\t\t\tlet newTest = test;\n\t\t\t\t\t\twhile (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\n\t\t\t\t\t\t\tnewTest = newTest.right;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenv.node.test = newTest.right;\n\t\t\t\t\t\tnewTest.right = env.node;\n\t\t\t\t\t\tenv.node = test;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.throwError('Expected :');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n};\n\n// Add default plugins:\n\njsep.plugins.register(ternary);\n\nexport { Jsep, jsep as default };\n","const ARROW_EXP = 'ArrowFunctionExpression';\n\nvar index = {\n\tname: 'arrow',\n\n\tinit(jsep) {\n\t\t// arrow-function expressions: () => x, v => v, (a, b) => v\n\t\tjsep.addBinaryOp('=>', 0.1, true);\n\n\t\t// this hook searches for the special case () => ...\n\t\t// which would normally throw an error because of the invalid LHS to the bin op\n\t\tjsep.hooks.add('gobble-expression', function gobbleEmptyArrowArg(env) {\n\t\t\tthis.gobbleSpaces();\n\t\t\tif (this.code === jsep.OPAREN_CODE) {\n\t\t\t\tconst backupIndex = this.index;\n\t\t\t\tthis.index++;\n\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tif (this.code === jsep.CPAREN_CODE) {\n\t\t\t\t\tthis.index++;\n\n\t\t\t\t\tconst biop = this.gobbleBinaryOp();\n\t\t\t\t\tif (biop === '=>') {\n\t\t\t\t\t\t// () => ...\n\t\t\t\t\t\tconst body = this.gobbleBinaryExpression();\n\t\t\t\t\t\tif (!body) {\n\t\t\t\t\t\t\tthis.throwError(\"Expected expression after \" + biop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenv.node = {\n\t\t\t\t\t\t\ttype: ARROW_EXP,\n\t\t\t\t\t\t\tparams: null,\n\t\t\t\t\t\t\tbody,\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.index = backupIndex;\n\t\t\t}\n\t\t});\n\n\t\tjsep.hooks.add('after-expression', function fixBinaryArrow(env) {\n\t\t\tupdateBinariesToArrows(env.node);\n\t\t});\n\n\t\tfunction updateBinariesToArrows(node) {\n\t\t\tif (node) {\n\t\t\t\t// Traverse full tree, converting any sub-object nodes as needed\n\t\t\t\tObject.values(node).forEach((val) => {\n\t\t\t\t\tif (val && typeof val === 'object') {\n\t\t\t\t\t\tupdateBinariesToArrows(val);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (node.operator === '=>') {\n\t\t\t\t\tnode.type = ARROW_EXP;\n\t\t\t\t\tnode.params = node.left ? [node.left] : null;\n\t\t\t\t\tnode.body = node.right;\n\t\t\t\t\tif (node.params && node.params[0].type === jsep.SEQUENCE_EXP) {\n\t\t\t\t\t\tnode.params = node.params[0].expressions;\n\t\t\t\t\t}\n\t\t\t\t\tdelete node.left;\n\t\t\t\t\tdelete node.right;\n\t\t\t\t\tdelete node.operator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexport { index as default };\n","var index = {\n\tname: 'new',\n\n\tinit(jsep) {\n\t\tjsep.addUnaryOp('new');\n\n\t\tjsep.hooks.add('after-token', function gobbleNew(env) {\n\t\t\tconst node = env.node;\n\t\t\tif (node && node.operator === 'new') {\n\t\t\t\tif (!node.argument || ![jsep.CALL_EXP, jsep.MEMBER_EXP].includes(node.argument.type)) {\n\t\t\t\t\tthis.throwError('Expected new function()');\n\t\t\t\t}\n\t\t\t\tenv.node = node.argument;\n\n\t\t\t\t// Change CALL_EXP to NewExpression (could be a nested member, even within a call expr)\n\t\t\t\tlet callNode = env.node;\n\t\t\t\twhile (callNode.type === jsep.MEMBER_EXP || (\n\t\t\t\t\tcallNode.type === jsep.CALL_EXP && callNode.callee.type === jsep.MEMBER_EXP)) {\n\t\t\t\t\tcallNode = callNode.type === jsep.MEMBER_EXP\n\t\t\t\t\t\t? callNode.object\n\t\t\t\t\t\t: callNode.callee.object;\n\t\t\t\t}\n\t\t\t\tcallNode.type = 'NewExpression';\n\t\t\t}\n\t\t});\n\t}\n};\n\nexport { index as default };\n","const NUM_0_CODE = 48;\nconst UNDERSCORE = 95;\n\nvar index = {\n\tname: 'numbers',\n\n\tinit(Jsep) {\n\t\tJsep.hooks.add('gobble-token', function gobbleNumber(env) {\n\t\t\tif (this.code === NUM_0_CODE) {\n\t\t\t\tconst startIndex = this.index;\n\t\t\t\tconst numType = this.expr.charAt(this.index + 1);\n\t\t\t\tconst ranges = getNumberCodeRanges.call(this, numType);\n\t\t\t\tif (!ranges) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet number = '';\n\t\t\t\twhile (isUnderscoreOrWithinRange(this.code, ranges)) {\n\t\t\t\t\tif (this.code === UNDERSCORE) {\n\t\t\t\t\t\tthis.index ++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// confirm valid syntax after building number string within ranges\n\t\t\t\tif (Jsep.isIdentifierPart(this.code)) {\n\t\t\t\t\tif (Jsep.isDecimalDigit(this.code) && Jsep.isDecimalDigit(numType.charCodeAt(0))) {\n\t\t\t\t\t\t// abort octal processing and reset to ignore the leading 0\n\t\t\t\t\t\tthis.index = startIndex + 1;\n\t\t\t\t\t\tgobbleBase10.call(this, env);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.throwError('unexpected char within number');\n\t\t\t\t}\n\n\t\t\t\tenv.node = {\n\t\t\t\t\ttype: Jsep.LITERAL,\n\t\t\t\t\tvalue: parseInt(number, getNumberBase(numType)),\n\t\t\t\t\traw: this.expr.substring(startIndex, this.index),\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (Jsep.isDecimalDigit(this.code) || this.code === Jsep.PERIOD_CODE) {\n\t\t\t\tgobbleBase10.call(this, env);\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Gets the range of allowable number codes (decimal) and updates index\n\t\t * @param {string} numType\n\t\t * @returns {number[][]|null}\n\t\t */\n\t\tfunction getNumberCodeRanges(numType) {\n\t\t\tif (numType === 'x' || numType === 'X') {\n\t\t\t\tthis.index += 2;\n\t\t\t\treturn [\n\t\t\t\t\t[48, 57], // 0-9\n\t\t\t\t\t[65, 70], // A-F\n\t\t\t\t\t[97, 102], // a-f\n\t\t\t\t];\n\t\t\t}\n\t\t\telse if (numType === 'b' || numType === 'B') {\n\t\t\t\tthis.index += 2;\n\t\t\t\treturn [[48, 49]]; // 0-1\n\t\t\t}\n\t\t\telse if (numType === 'o' || numType === 'O' ||\n\t\t\t\t(numType >= '0' && numType <= '7')) { // 0-7 allows non-standard 0644 = 420\n\t\t\t\tthis.index += numType <= '7' ? 1 : 2;\n\t\t\t\treturn [[48, 55]]; // 0-7\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Supports Hex, Octal and Binary only\n\t\t * @param {string} numType\n\t\t * @returns {16|8|2}\n\t\t */\n\t\tfunction getNumberBase(numType) {\n\t\t\tif (numType === 'x' || numType === 'X') {\n\t\t\t\treturn 16;\n\t\t\t}\n\t\t\telse if (numType === 'b' || numType === 'B') {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t// default (includes non-stand 044)\n\t\t\treturn 8;\n\t\t}\n\n\t\t/**\n\t\t * Verifies number code is within given ranges\n\t\t * @param {number} code\n\t\t * @param {number[][]} ranges\n\t\t */\n\t\tfunction isUnderscoreOrWithinRange(code, ranges) {\n\t\t\treturn code === UNDERSCORE ||\n\t\t\t\tranges.some(([min, max]) => code >= min && code <= max);\n\t\t}\n\n\t\t/**\n\t\t * Same as core gobbleNumericLiteral, but allows for _ char\n\t\t * @param {{ context?: typeof Jsep, node?: Expression }} env\n\t\t */\n\t\tfunction gobbleBase10(env) {\n\t\t\tconst startIndex = this.index;\n\t\t\tlet number = '';\n\n\t\t\tconst gobbleDigits = () => {\n\t\t\t\twhile (Jsep.isDecimalDigit(this.code) || this.code === UNDERSCORE) {\n\t\t\t\t\tif (this.code === UNDERSCORE) {\n\t\t\t\t\t\tthis.index++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tgobbleDigits();\n\t\t\tif (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\n\t\t\t\tgobbleDigits();\n\t\t\t}\n\n\t\t\tlet ch = this.char;\n\t\t\tif (ch === 'e' || ch === 'E') { // exponent marker\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t\tch = this.char;\n\n\t\t\t\tif (ch === '+' || ch === '-') { // exponent sign\n\t\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t\t}\n\n\t\t\t\tgobbleDigits(); // exponent itself\n\n\t\t\t\tif (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ) {\n\t\t\t\t\tthis.throwError('Expected exponent (' + number + this.char + ')');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst chCode = this.code;\n\n\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\n\t\t\tif (Jsep.isIdentifierStart(chCode)) {\n\t\t\t\tthis.throwError('Variable names cannot start with a number (' +\n\t\t\t\t\tnumber + this.char + ')');\n\t\t\t}\n\t\t\telse if (chCode === Jsep.PERIOD_CODE) {\n\t\t\t\tif (number.length > 1) {\n\t\t\t\t\tthis.throwError(`Unexpected period ${JSON.stringify({ chCode, number }, null, 2)}`);\n\t\t\t\t}\n\t\t\t\t// leave other error-handling to jsep core. Also allows spread operator.\n\t\t\t\tthis.index = startIndex;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tenv.node = {\n\t\t\t\ttype: Jsep.LITERAL,\n\t\t\t\tvalue: parseFloat(number),\n\t\t\t\traw: this.expr.substring(startIndex, this.index),\n\t\t\t};\n\t\t}\n\t}\n};\n\nexport { index as default };\n","const FSLASH_CODE = 47; // '/'\nconst BSLASH_CODE = 92; // '\\\\'\n\nvar index = {\n\tname: 'regex',\n\n\tinit(jsep) {\n\t\t// Regex literal: /abc123/ig\n\t\tjsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {\n\t\t\tif (this.code === FSLASH_CODE) {\n\t\t\t\tconst patternIndex = ++this.index;\n\n\t\t\t\tlet inCharSet = false;\n\t\t\t\twhile (this.index < this.expr.length) {\n\t\t\t\t\tif (this.code === FSLASH_CODE && !inCharSet) {\n\t\t\t\t\t\tconst pattern = this.expr.slice(patternIndex, this.index);\n\n\t\t\t\t\t\tlet flags = '';\n\t\t\t\t\t\twhile (++this.index < this.expr.length) {\n\t\t\t\t\t\t\tconst code = this.code;\n\t\t\t\t\t\t\tif ((code >= 97 && code <= 122) // a...z\n\t\t\t\t\t\t\t\t|| (code >= 65 && code <= 90) // A...Z\n\t\t\t\t\t\t\t\t|| (code >= 48 && code <= 57)) { // 0-9\n\t\t\t\t\t\t\t\tflags += this.char;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet value;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvalue = new RegExp(pattern, flags);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\tthis.throwError(e.message);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tenv.node = {\n\t\t\t\t\t\t\ttype: jsep.LITERAL,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\traw: this.expr.slice(patternIndex - 1, this.index),\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// allow . [] and () after regex: /regex/.test(a)\n\t\t\t\t\t\tenv.node = this.gobbleTokenProperty(env.node);\n\t\t\t\t\t\treturn env.node;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.code === jsep.OBRACK_CODE) {\n\t\t\t\t\t\tinCharSet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (inCharSet && this.code === jsep.CBRACK_CODE) {\n\t\t\t\t\t\tinCharSet = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis.index += this.code === BSLASH_CODE ? 2 : 1;\n\t\t\t\t}\n\t\t\t\tthis.throwError('Unclosed Regex');\n\t\t\t}\n\t\t});\n\t},\n};\n\nexport { index as default };\n","const CONDITIONAL_EXP = 'ConditionalExpression';\n\nvar index = {\n\tname: 'ternary',\n\n\tinit(jsep) {\n\t\t// Ternary expression: test ? consequent : alternate\n\t\tjsep.hooks.add('after-expression', function gobbleTernary(env) {\n\t\t\tif (env.node && this.code === jsep.QUMARK_CODE) {\n\t\t\t\tthis.index++;\n\t\t\t\tconst test = env.node;\n\t\t\t\tconst consequent = this.gobbleExpression();\n\n\t\t\t\tif (!consequent) {\n\t\t\t\t\tthis.throwError('Expected expression');\n\t\t\t\t}\n\n\t\t\t\tthis.gobbleSpaces();\n\n\t\t\t\tif (this.code === jsep.COLON_CODE) {\n\t\t\t\t\tthis.index++;\n\t\t\t\t\tconst alternate = this.gobbleExpression();\n\n\t\t\t\t\tif (!alternate) {\n\t\t\t\t\t\tthis.throwError('Expected expression');\n\t\t\t\t\t}\n\t\t\t\t\tenv.node = {\n\t\t\t\t\t\ttype: CONDITIONAL_EXP,\n\t\t\t\t\t\ttest,\n\t\t\t\t\t\tconsequent,\n\t\t\t\t\t\talternate,\n\t\t\t\t\t};\n\n\t\t\t\t\t// check for operators of higher priority than ternary (i.e. assignment)\n\t\t\t\t\t// jsep sets || at 1, and assignment at 0.9, and conditional should be between them\n\t\t\t\t\tif (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\n\t\t\t\t\t\tlet newTest = test;\n\t\t\t\t\t\twhile (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\n\t\t\t\t\t\t\tnewTest = newTest.right;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenv.node.test = newTest.right;\n\t\t\t\t\t\tnewTest.right = env.node;\n\t\t\t\t\t\tenv.node = test;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.throwError('Expected :');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n};\n\nexport { index as default };\n","const BTICK_CODE = 96; // `\nconst CCURLY_CODE = 125; // }\nconst TAGGED_TEMPLATE_EXPRESSION = 'TaggedTemplateExpression';\nconst TEMPLATE_LITERAL = 'TemplateLiteral';\nconst TEMPLATE_ELEMENT = 'TemplateElement';\n\nvar index = {\n\tname: 'jsepTemplateLiteral',\n\n\tinit(jsep) {\n\t\tfunction gobbleTemplateLiteral(env, gobbleMember = true) {\n\t\t\tif (this.code === BTICK_CODE) {\n\t\t\t\tconst node = {\n\t\t\t\t\ttype: TEMPLATE_LITERAL,\n\t\t\t\t\tquasis: [],\n\t\t\t\t\texpressions: [],\n\t\t\t\t};\n\t\t\t\tlet cooked = '';\n\t\t\t\tlet raw = '';\n\t\t\t\tlet closed = false;\n\t\t\t\tconst length = this.expr.length;\n\t\t\t\tconst pushQuasi = () => node.quasis.push({\n\t\t\t\t\ttype: TEMPLATE_ELEMENT,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\traw,\n\t\t\t\t\t\tcooked,\n\t\t\t\t\t},\n\t\t\t\t\ttail: closed,\n\t\t\t\t});\n\n\t\t\t\twhile (this.index < length) {\n\t\t\t\t\tlet ch = this.expr.charAt(++this.index);\n\n\t\t\t\t\tif (ch === '`') {\n\t\t\t\t\t\tthis.index += 1;\n\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\tpushQuasi();\n\n\t\t\t\t\t\tenv.node = node;\n\n\t\t\t\t\t\tif (gobbleMember) {\n\t\t\t\t\t\t  // allow . [] and () after template: `foo`.length\n\t\t\t\t\t\t  env.node = this.gobbleTokenProperty(env.node);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn env.node;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch === '$' && this.expr.charAt(this.index + 1) === '{') {\n\t\t\t\t\t\tthis.index += 2;\n\t\t\t\t\t\tpushQuasi();\n\t\t\t\t\t\traw = '';\n\t\t\t\t\t\tcooked = '';\n\t\t\t\t\t\tnode.expressions.push(...this.gobbleExpressions(CCURLY_CODE));\n\t\t\t\t\t\tif (this.code !== CCURLY_CODE) {\n\t\t\t\t\t\t\tthis.throwError('unclosed ${');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch === '\\\\') {\n\t\t\t\t\t\t// Check for all of the common escape codes\n\t\t\t\t\t\traw += ch;\n\t\t\t\t\t\tch = this.expr.charAt(++this.index);\n\t\t\t\t\t\traw += ch;\n\n\t\t\t\t\t\tswitch (ch) {\n\t\t\t\t\t\t\tcase 'n': cooked += '\\n'; break;\n\t\t\t\t\t\t\tcase 'r': cooked += '\\r'; break;\n\t\t\t\t\t\t\tcase 't': cooked += '\\t'; break;\n\t\t\t\t\t\t\tcase 'b': cooked += '\\b'; break;\n\t\t\t\t\t\t\tcase 'f': cooked += '\\f'; break;\n\t\t\t\t\t\t\tcase 'v': cooked += '\\x0B'; break;\n\t\t\t\t\t\t\tdefault : cooked += ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcooked += ch;\n\t\t\t\t\t\traw += ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.throwError('Unclosed `');\n\t\t\t}\n\t\t}\n\n\t\tjsep.hooks.add('gobble-token', gobbleTemplateLiteral);\n\n\t\tjsep.hooks.add('after-token', function gobbleTaggedTemplateIdentifier(env) {\n\t\t\tif ((env.node.type === jsep.IDENTIFIER || env.node.type === jsep.MEMBER_EXP) && this.code === BTICK_CODE) {\n\t\t\t\tenv.node = {\n\t\t\t\t\ttype: TAGGED_TEMPLATE_EXPRESSION,\n\t\t\t\t\ttag: env.node,\n\t\t\t\t\tquasi: gobbleTemplateLiteral.bind(this)(env, false),\n\t\t\t\t};\n\n\t\t\t\t// allow . [] and () after tagged template: bar`foo`.length\n\t\t\t\tenv.node = this.gobbleTokenProperty(env.node);\n\n\t\t\t\treturn env.node;\n\t\t\t}\n\t\t});\n\t}\n};\n\nexport { index as default };\n","/** @category Utility */\nimport jsep from 'jsep';\nimport jsepArrow, { type ArrowExpression } from '@jsep-plugin/arrow';\nimport jsepNew, { type NewExpression } from '@jsep-plugin/new';\nimport jsepNumbers from '@jsep-plugin/numbers';\nimport jsepRegex from '@jsep-plugin/regex';\nimport jsepTernary from '@jsep-plugin/ternary';\nimport jsepTemplate, { type TemplateElement, type TemplateLiteral } from '@jsep-plugin/template';\n\njsep.plugins.register(jsepArrow);\njsep.plugins.register(jsepNew);\njsep.plugins.register(jsepNumbers);\njsep.plugins.register(jsepRegex);\njsep.plugins.register(jsepTernary);\njsep.plugins.register(jsepTemplate);\n// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence\n// for the order defined here\n// 7 is jsep's internal for \"relational operators\"\njsep.addBinaryOp('in', 7);\njsep.addBinaryOp('??', 1);\n\n/** An object containing the variable to use when evaluating this expression */\nexport type VariablesMap = {\n  [key: string]: string | number | boolean | Function | RegExp | object | null | VariablesMap | Array<VariablesMap>;\n};\n\n/** The valid return types for `evaluate()` and `evaluateAsync()` */\nexport type DefaultEvaluateReturnType = string | number | boolean | Date | null | undefined;\n\n/**\n * `evaluate()` implements a relatively safe version of `eval()` that is limited to evaluating synchronous\n * Javascript expressions. This allows us to safely add features that depend on user-supplied code without\n * polluting the global namespace or needing to support `eval()` and the like.\n *\n * By default it supports any expression that evalutes to a string, number, boolean, Date, null, or undefined.\n * Other values will result in an error.\n *\n * @example\n * ```ts\n * // shouldDisplayOptionalData will be false\n * const shouldDisplayOptionalData = evaluate('!isEmpty(array)', {\n *  array: [],\n *  isEmpty(arr: unknown) {\n *   return Array.isArray(arr) && arr.length === 0;\n *  }\n * })\n * ```\n *\n * Since this only implements the expression lanaguage part of Javascript, there is no support for assigning\n * values, creating functions, or creating objects, so the following will throw an error:\n *\n * @example\n * ```ts\n * evaluate('var a = 1; a');\n * ```\n *\n * In addition to string expressions, `evaluate()` can use an existing `jsep.Expression`, such as that returned\n * from the `compile()` function. The goal here is to support cases where the same expression will be evaluated\n * multiple times, possibly with different variables, e.g.,\n *\n * @example\n * ```ts\n * const expr = compile('isEmpty(array)');\n *\n * // then we use it like\n * evaluate(expr, {\n *  array: [],\n *  isEmpty(arr: unknown) {\n *   return Array.isArray(arr) && arr.length === 0;\n *  }\n * ));\n *\n * evaluate(expr, {\n *  array: ['value'],\n *  isEmpty(arr: unknown) {\n *   return Array.isArray(arr) && arr.length === 0;\n *  }\n * ));\n * ```\n *\n * This saves the overhead of parsing the expression everytime and simply allows us to evaluate it.\n *\n * The `variables` parameter should be used to supply any variables or functions that should be in-scope for\n * the evaluation. A very limited number of global objects, like NaN and Infinity are always available, but\n * any non-global values will need to be passed as a variable. Note that expressions do not have any access to\n * the variables in the scope in which they were defined unless they are supplied here.\n *\n * @param expression The expression to evaluate, either as a string or pre-parsed expression\n * @param variables Optional object which contains any variables, functions, etc. that will be available to\n *  the expression.\n * @returns The result of evaluating the expression\n */\nexport function evaluate(expression: string | jsep.Expression, variables: VariablesMap = {}) {\n  return evaluateAsType(expression, variables, defaultTypePredicate);\n}\n\n/**\n * `evaluateAsync()` implements a relatively safe version of `eval()` that can evaluate Javascript expressions\n * that use Promises. This allows us to safely add features that depend on user-supplied code without\n * polluting the global namespace or needing to support `eval()` and the like.\n *\n * By default it supports any expression that evalutes to a string, number, boolean, Date, null, or undefined.\n * Other values will result in an error.\n *\n * @example\n * ```ts\n * // shouldDisplayOptionalData will be false\n * const shouldDisplayOptionalData = await evaluateAsync('Promise.resolve(!isEmpty(array))', {\n *  array: [],\n *  isEmpty(arr: unknown) {\n *   return Array.isArray(arr) && arr.length === 0;\n *  }\n * })\n * ```\n *\n * Since this only implements the expression lanaguage part of Javascript, there is no support for assigning\n * values, creating functions, or creating objects, so the following will throw an error:\n *\n * @example\n * ```ts\n * evaluateAsync('var a = 1; a');\n * ```\n *\n * In addition to string expressions, `evaluate()` can use an existing `jsep.Expression`, such as that returned\n * from the `compile()` function. The goal here is to support cases where the same expression will be evaluated\n * multiple times, possibly with different variables, e.g.,\n *\n * @example\n * ```ts\n * const expr = compile('Promise.resolve(isEmpty(array))');\n *\n * // then we use it like\n * evaluateAsync(expr, {\n *  array: [],\n *  isEmpty(arr: unknown) {\n *   return Array.isArray(arr) && arr.length === 0;\n *  }\n * ));\n *\n * evaluateAsync(expr, {\n *  array: ['value'],\n *  isEmpty(arr: unknown) {\n *   return Array.isArray(arr) && arr.length === 0;\n *  }\n * ));\n * ```\n *\n * This saves the overhead of parsing the expression everytime and simply allows us to evaluate it.\n *\n * The `variables` parameter should be used to supply any variables or functions that should be in-scope for\n * the evaluation. A very limited number of global objects, like NaN and Infinity are always available, but\n * any non-global values will need to be passed as a variable. Note that expressions do not have any access to\n * the variables in the scope in which they were defined unless they are supplied here.\n *\n * **Note:** `evaluateAsync()` currently only supports Promise-based asynchronous flows and does not support\n * the `await` keyword.\n *\n * @param expression The expression to evaluate, either as a string or pre-parsed expression\n * @param variables Optional object which contains any variables, functions, etc. that will be available to\n *  the expression.\n * @returns The result of evaluating the expression\n */\nexport async function evaluateAsync(expression: string | jsep.Expression, variables: VariablesMap = {}) {\n  return evaluateAsTypeAsync(expression, variables, defaultTypePredicate);\n}\n\n/**\n * `evaluateAsBoolean()` is a variant of {@link evaluate()} which only supports boolean results. Useful\n * if valid expression must return boolean values.\n *\n * @param expression The expression to evaluate, either as a string or pre-parsed expression\n * @param variables Optional object which contains any variables, functions, etc. that will be available to\n *  the expression.\n * @returns The result of evaluating the expression\n */\nexport function evaluateAsBoolean(expression: string | jsep.Expression, variables: VariablesMap = {}) {\n  return evaluateAsType(expression, variables, booleanTypePredicate);\n}\n\n/**\n * `evaluateAsBooleanAsync()` is a variant of {@link evaluateAsync()} which only supports boolean results. Useful\n * if valid expression must return boolean values.\n *\n * @param expression The expression to evaluate, either as a string or pre-parsed expression\n * @param variables Optional object which contains any variables, functions, etc. that will be available to\n *  the expression.\n * @returns The result of evaluating the expression\n */\nexport function evaluateAsBooleanAsync(expression: string | jsep.Expression, variables: VariablesMap = {}) {\n  return evaluateAsTypeAsync(expression, variables, booleanTypePredicate);\n}\n\n/**\n * `evaluateAsNumber()` is a variant of {@link evaluate()} which only supports number results. Useful\n * if valid expression must return numeric values.\n *\n * @param expression The expression to evaluate, either as a string or pre-parsed expression\n * @param variables Optional object which contains any variables, functions, etc. that will be available to\n *  the expression.\n * @returns The result of evaluating the expression\n */\nexport function evaluateAsNumber(expression: string | jsep.Expression, variables: VariablesMap = {}) {\n  return evaluateAsType(expression, variables, numberTypePredicate);\n}\n\n/**\n * `evaluateAsNumberAsync()` is a variant of {@link evaluateAsync()} which only supports number results. Useful\n * if valid expression must return numeric values.\n *\n * @param expression The expression to evaluate, either as a string or pre-parsed expression\n * @param variables Optional object which contains any variables, functions, etc. that will be available to\n *  the expression.\n * @returns The result of evaluating the expression\n */\nexport function evaluateAsNumberAsync(expression: string | jsep.Expression, variables: VariablesMap = {}) {\n  return evaluateAsType(expression, variables, numberTypePredicate);\n}\n\n/**\n * `evaluateAsType()` is a type-safe version of {@link evaluate()} which returns a result if the result\n * passes a custom type predicate. The main use-case for this is to narrow the return types allowed based on\n * context, e.g., if the expected result should be a number or boolean, you can supply a custom type-guard\n * to ensure that only number or boolean results are returned.\n *\n * @param expression The expression to evaluate, either as a string or pre-parsed expression\n * @param variables Optional object which contains any variables, functions, etc. that will be available to\n *  the expression.\n * @param typePredicate A [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)\n *  which asserts that the result value matches one of the expected results.\n * @returns The result of evaluating the expression\n */\nexport function evaluateAsType<T>(\n  expression: string | jsep.Expression,\n  variables: VariablesMap = {},\n  typePredicate: (result: unknown) => result is T,\n): T {\n  if (typeof expression !== 'string' && (typeof expression !== 'object' || !expression || !('type' in expression))) {\n    throw `Unknown expression type ${expression}. Expressions must either be a string or pre-compiled string.`;\n  }\n\n  if (typeof variables === 'undefined' || variables === null) {\n    variables = {};\n  }\n\n  const context = createSynchronousContext(variables);\n  const result = visitExpression(typeof expression === 'string' ? jsep(expression) : expression, context);\n  if (typePredicate(result)) {\n    return result;\n  } else {\n    throw {\n      type: 'Invalid result',\n      message:\n        typeof expression === 'string'\n          ? `The expression ${expression} did not produce a valid result`\n          : 'The expression did not produce a valid result',\n    };\n  }\n}\n\n/**\n * `evaluateAsTypeAsync()` is a type-safe version of {@link evaluateAsync()} which returns a result if the result\n * passes a custom type predicate. The main use-case for this is to narrow the return types allowed based on\n * context, e.g., if the expected result should be a number or boolean, you can supply a custom type-guard\n * to ensure that only number or boolean results are returned.\n *\n * @param expression The expression to evaluate, either as a string or pre-parsed expression\n * @param variables Optional object which contains any variables, functions, etc. that will be available to\n *  the expression.\n * @param typePredicate A [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)\n *  which asserts that the result value matches one of the expected results.\n * @returns The result of evaluating the expression\n */\nexport async function evaluateAsTypeAsync<T>(\n  expression: string | jsep.Expression,\n  variables: VariablesMap = {},\n  typePredicate: (result: unknown) => result is T,\n): Promise<T> {\n  if (typeof expression !== 'string' && (typeof expression !== 'object' || !expression || !('type' in expression))) {\n    return Promise.reject(\n      `Unknown expression type ${expression}. Expressions must either be a string or pre-compiled string.`,\n    );\n  }\n\n  if (typeof variables === 'undefined' || variables === null) {\n    variables = {};\n  }\n\n  const context = createAsynchronousContext(variables);\n  return Promise.resolve(visitExpression(typeof expression === 'string' ? jsep(expression) : expression, context)).then(\n    (result) => {\n      if (typePredicate(result)) {\n        return result;\n      } else {\n        throw {\n          type: 'Invalid result',\n          message:\n            typeof expression === 'string'\n              ? `The expression ${expression} did not produce a valid result`\n              : 'The expression did not produce a valid result',\n        };\n      }\n    },\n  );\n}\n\n/**\n * `compile()` is a companion function for use with {@link evaluate()} and the various `evaluateAs*()` functions.\n * It processes an expression string into the resulting AST that is executed by those functions. This is useful if\n * you have an expression that will need to be evaluated mulitple times, potentially with different values, as the\n * lexing and parsing steps can be skipped by using the AST object returned from this.\n *\n * The returned AST is intended to be opaque to client applications, but, of course, it is possible to manipulate\n * the AST before passing it back to {@link evaluate()}, if desired. This might be useful if, for example, certain\n * values are known to be constant.\n *\n * @param expression The expression to be parsed\n * @returns An executable AST representation of the expression\n */\nexport function compile(expression: string): jsep.Expression {\n  return jsep(expression);\n}\n\n// Pre-defined type guards\nfunction defaultTypePredicate(result: unknown): result is DefaultEvaluateReturnType {\n  return (\n    typeof result === 'string' ||\n    typeof result === 'number' ||\n    typeof result === 'boolean' ||\n    typeof result === 'undefined' ||\n    result === null ||\n    result instanceof Date\n  );\n}\n\nfunction booleanTypePredicate(result: unknown): result is Boolean {\n  return typeof result === 'boolean';\n}\n\nfunction numberTypePredicate(result: unknown): result is number {\n  return typeof result === 'number';\n}\n\n// Implementation\n\n// This is the core of the implementation; it takes an expression, the variables and the current object\n// each expression is dispatched to an appropriate handler.\nfunction visitExpression(expression: jsep.Expression, context: EvaluationContext) {\n  switch (expression.type) {\n    case 'UnaryExpression':\n      return visitUnaryExpression(expression as jsep.UnaryExpression, context);\n    case 'BinaryExpression':\n      return visitBinaryExpression(expression as jsep.BinaryExpression, context);\n    case 'ConditionalExpression':\n      return visitConditionalExpression(expression as jsep.ConditionalExpression, context);\n    case 'CallExpression':\n      return visitCallExpression(expression as jsep.CallExpression, context);\n    case 'ArrowFunctionExpression':\n      return visitArrowFunctionExpression(expression as ArrowExpression, context);\n    case 'MemberExpression':\n      return visitMemberExpression(expression as jsep.MemberExpression, context);\n    case 'ArrayExpression':\n      return visitArrayExpression(expression as jsep.ArrayExpression, context);\n    case 'SequenceExpression':\n      return visitSequenceExpression(expression as jsep.SequenceExpression, context);\n    case 'NewExpression':\n      return visitNewExpression(expression as NewExpression, context);\n    case 'Literal':\n      return visitLiteral(expression as jsep.Literal, context);\n    case 'Identifier':\n      return visitIdentifier(expression as jsep.Identifier, context);\n    case 'TemplateLiteral':\n      return visitTemplateLiteral(expression as TemplateLiteral, context);\n    case 'TemplateElement':\n      return visitTemplateElement(expression as TemplateElement, context);\n    default:\n      throw `Expression evaluator does not support expression of type '${expression.type}'`;\n  }\n}\n\nfunction visitExpressionName(expression: jsep.Expression, context: EvaluationContext) {\n  switch (expression.type) {\n    case 'Literal':\n      return (expression as jsep.Literal).value as string;\n    case 'Identifier':\n      return (expression as jsep.Identifier).name;\n    case 'MemberExpression':\n      return visitExpressionName((expression as jsep.MemberExpression).property, context);\n    default:\n      throw `VisitExpressionName does not support expression of type '${expression.type}'`;\n  }\n}\n\nfunction visitUnaryExpression(expression: jsep.UnaryExpression, context: EvaluationContext) {\n  const value = visitExpression(expression.argument, context);\n\n  switch (expression.operator) {\n    case '+':\n      return +value;\n    case '-':\n      return -value;\n    case '~':\n      return ~value;\n    case '!':\n      return !value;\n    default:\n      throw `Expression evaluator does not support operator '${expression.operator}''`;\n  }\n}\n\nfunction visitBinaryExpression(expression: jsep.BinaryExpression, context: EvaluationContext) {\n  let left = visitExpression(expression.left, context);\n  let right = visitExpression(expression.right, context);\n\n  switch (expression.operator) {\n    case '+':\n      return left + right;\n    case '-':\n      return left - right;\n    case '*':\n      return left * right;\n    case '/':\n      return left / right;\n    case '%':\n      return left % right;\n    case '**':\n      return left ** right;\n    case '==':\n      return left == right;\n    case '===':\n      return left === right;\n    case '!=':\n      return left != right;\n    case '!==':\n      return left !== right;\n    case '>':\n      return left > right;\n    case '>=':\n      return left >= right;\n    case '<':\n      return left < right;\n    case '<=':\n      return left <= right;\n    case 'in':\n      return left in right;\n    case '&&':\n      return left && right;\n    case '||':\n      return left || right;\n    case '??':\n      return left ?? right;\n    default:\n      throw `Expression evaluator does not support operator '${expression.operator}' operator`;\n  }\n}\n\nfunction visitConditionalExpression(expression: jsep.ConditionalExpression, context: EvaluationContext) {\n  const test = visitExpression(expression.test, context);\n  return test ? visitExpression(expression.consequent, context) : visitExpression(expression.alternate, context);\n}\n\nfunction visitCallExpression(expression: jsep.CallExpression, context: EvaluationContext) {\n  let args = expression.arguments?.map(handleNullableExpression(context));\n  let callee = visitExpression(expression.callee, context);\n\n  if (!callee) {\n    throw `No function named ${expression.callee} is defined in this context`;\n  } else if (!(callee instanceof Function)) {\n    throw `${expression.callee} is not a function`;\n  }\n\n  return callee(...args);\n}\n\nfunction visitArrowFunctionExpression(expression: ArrowExpression, context: EvaluationContext) {\n  const params =\n    expression.params?.map((p) => {\n      switch (p.type) {\n        case 'Identifier':\n          return (p as jsep.Identifier).name;\n        default:\n          throw `Cannot handle parameter of type ${p.type}`;\n      }\n    }) ?? [];\n\n  return function (...rest: unknown[]) {\n    if (rest.length < params.length) {\n      throw `Required argument(s) ${params.slice(rest.length, -1).join(', ')} were not provided`;\n    }\n\n    const vars = Object.fromEntries(\n      params.reduce((acc: Array<[string, VariablesMap['a']]>, p, idx) => {\n        const val = rest[idx];\n        if (isValidVariableType(val)) {\n          acc.push([p, val]);\n        }\n        return acc;\n      }, []),\n    );\n\n    return visitExpression(expression.body, context.addVariables(vars));\n  }.bind(context.thisObj ?? null);\n}\n\nfunction visitMemberExpression(expression: jsep.MemberExpression, context: EvaluationContext) {\n  let obj = visitExpression(expression.object, context);\n\n  if (obj === undefined) {\n    switch (expression.object.type) {\n      case 'Identifier': {\n        let objectName = visitExpressionName(expression.object, context);\n        throw ReferenceError(`ReferenceError: ${objectName} is not defined`);\n      }\n      case 'MemberExpression': {\n        let propertyName = visitExpressionName(expression.property, context);\n        throw TypeError(`TypeError: cannot read properties of undefined (reading '${propertyName}')`);\n      }\n      default:\n        throw `VisitMemberExpression does not support operator '${expression.object.type}' type`;\n    }\n  }\n\n  let newObj = obj;\n  if (typeof obj === 'string') {\n    newObj = String.prototype;\n  } else if (typeof obj === 'number') {\n    newObj = Number.prototype;\n  } else if (typeof obj === 'function') {\n    // no-op\n  } else if (typeof obj !== 'object') {\n    throw `VisitMemberExpression does not support member access on type ${typeof obj}`;\n  }\n\n  context.thisObj = newObj;\n\n  let result: unknown;\n  switch (expression.property.type) {\n    case 'Identifier':\n    case 'MemberExpression':\n      result = visitExpression(expression.property, context);\n      break;\n    default: {\n      const property = visitExpression(expression.property, context);\n      if (typeof property === 'undefined') {\n        throw { type: 'Illegal property access', message: 'No property was supplied to the property access' };\n      }\n      validatePropertyName(property);\n      result = obj[property];\n    }\n  }\n\n  if (typeof result === 'function') {\n    return result.bind(obj);\n  }\n\n  return result;\n}\n\nfunction visitArrayExpression(expression: jsep.ArrayExpression, context: EvaluationContext) {\n  return expression.elements?.map(handleNullableExpression(context));\n}\n\nfunction visitSequenceExpression(expression: jsep.SequenceExpression, context: EvaluationContext) {\n  const result = expression.expressions.map(handleNullableExpression(context));\n  return result[result.length - 1];\n}\n\nfunction visitNewExpression(expression: NewExpression, context: EvaluationContext) {\n  if (expression.callee && expression.callee.type === 'Identifier') {\n    let args = expression.arguments?.map(handleNullableExpression(context)) as Array<any>;\n    switch (expression.callee.name) {\n      case 'Date': {\n        /** @ts-ignore because we can use the spread operator here */\n        return new Date(...args);\n      }\n      case 'RegExp':\n        /** @ts-ignore because we can use the spread operator here */\n        return new RegExp(...args);\n      default:\n        throw `Cannot instantiate object of type ${expression.callee.name}`;\n    }\n  } else {\n    if (!expression.callee) {\n      throw `Could not handle \"new\" without a specified class`;\n    } else {\n      throw 'new must be called with either Date or RegExp';\n    }\n  }\n}\n\nfunction visitTemplateLiteral(expression: TemplateLiteral, context: EvaluationContext) {\n  const expressions: Array<unknown> = expression.expressions?.map(handleNullableExpression(context)) ?? [];\n  const quasis: Array<{ tail: boolean; value: unknown }> =\n    expression.quasis?.map(handleNullableExpression(context)) ?? [];\n  return (\n    quasis\n      .filter((q) => !q.tail)\n      .map((q) => q.value)\n      .join('') +\n    expressions.join('') +\n    quasis\n      .filter((q) => q.tail)\n      .map((q) => q.value)\n      .join('')\n  );\n}\n\nfunction visitTemplateElement(expression: TemplateElement, context: EvaluationContext) {\n  return { value: expression.cooked, tail: expression.tail };\n}\n\nfunction visitIdentifier(expression: jsep.Identifier, context: EvaluationContext) {\n  validatePropertyName(expression.name);\n\n  // we support both `object` and `function` in the same way as technically property access on functions\n  // is possible; the use-case here is to support JS's \"static\" functions like `Number.isInteger()`, which\n  // is technically reading a property on a function\n  const thisObj = context.thisObj;\n  if (thisObj && (typeof thisObj === 'object' || typeof thisObj === 'function') && expression.name in thisObj) {\n    const result = thisObj[expression.name];\n    validatePropertyName(result);\n    return result;\n  } else if (context.variables && expression.name in context.variables) {\n    const result = context.variables[expression.name];\n    validatePropertyName(result);\n    return result;\n  } else if (expression.name in context.globals) {\n    return context.globals[expression.name];\n  } else {\n    return undefined;\n  }\n}\n\nfunction visitLiteral(expression: jsep.Literal, context: EvaluationContext) {\n  validatePropertyName(expression.value);\n  return expression.value;\n}\n\n// Internal helpers and utilities\n\ninterface EvaluationContext {\n  thisObj: object | undefined;\n  variables: VariablesMap;\n  globals: typeof globals | typeof globalsAsync;\n  addVariables(vars: VariablesMap): EvaluationContext;\n}\n\nfunction createSynchronousContext(variables: VariablesMap): EvaluationContext {\n  return createContextInternal(variables, globals);\n}\n\nfunction createAsynchronousContext(variables: VariablesMap): EvaluationContext {\n  return createContextInternal(variables, globalsAsync);\n}\n\nfunction createContextInternal(variables: VariablesMap, globals_: typeof globals | typeof globalsAsync) {\n  const context = {\n    thisObj: undefined,\n    variables: { ...variables },\n    globals: { ...globals_ },\n    addVariables(vars: VariablesMap) {\n      this.variables = { ...this.variables, ...vars };\n      return this;\n    },\n  };\n\n  context.addVariables.bind(context);\n\n  return context;\n}\n\n// helper useful for handling arrays of expressions, since `null` expressions should not be\n// dispatched to `visitExpression()`\nfunction handleNullableExpression(context: EvaluationContext) {\n  return function handleNullableExpressionInner(expression: jsep.Expression | null) {\n    if (expression === null) {\n      return null;\n    }\n\n    return visitExpression(expression, context);\n  };\n}\n\nfunction validatePropertyName(name: unknown) {\n  if (name === '__proto__' || name === 'prototype' || name === 'constructor') {\n    throw { type: 'Illegal property access', message: `Cannot access the ${name} property of objects` };\n  }\n}\n\nfunction isValidVariableType(val: unknown): val is VariablesMap['a'] {\n  if (\n    typeof val === 'string' ||\n    typeof val === 'number' ||\n    typeof val === 'boolean' ||\n    typeof val === 'function' ||\n    val === null ||\n    val instanceof RegExp\n  ) {\n    return true;\n  }\n\n  if (typeof val === 'object') {\n    for (const key of Object.keys(val)) {\n      if (!isValidVariableType(val[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (Array.isArray(val)) {\n    for (const item of val) {\n      if (!isValidVariableType(item)) {\n        return false;\n      }\n    }\n  }\n\n  return false;\n}\n\nconst globals = {\n  Array,\n  Boolean,\n  Symbol,\n  Infinity,\n  NaN,\n  Math,\n  Number,\n  BigInt,\n  String,\n  RegExp,\n  JSON,\n  isFinite,\n  isNaN,\n  parseFloat,\n  parseInt,\n  decodeURI,\n  encodeURI,\n  encodeURIComponent,\n  Object: {\n    __proto__: undefined,\n    assign: Object.assign.bind(null),\n    fromEntries: Object.fromEntries.bind(null),\n    hasOwn: Object.hasOwn.bind(null),\n    keys: Object.keys.bind(null),\n    is: Object.is.bind(null),\n    values: Object.values.bind(null),\n  },\n};\n\nconst globalsAsync = {\n  ...globals,\n  Promise,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Jsep","version","static","op_name","max_unop_len","Math","max","length","unary_ops","precedence","isRightAssociative","max_binop_len","binary_ops","right_associative","add","delete","char","additional_identifier_chars","literal_name","literal_value","literals","getMaxKeyLen","this","expr","charAt","index","code","charCodeAt","constructor","parse","keys","map","k","ch","op_val","String","fromCharCode","has","isIdentifierStart","isDecimalDigit","throwError","message","error","Error","description","runHook","name","node","hooks","env","context","run","searchHook","find","callback","gobbleSpaces","SPACE_CODE","TAB_CODE","LF_CODE","CR_CODE","nodes","gobbleExpressions","type","COMPOUND","body","untilICode","ch_i","SEMCOL_CODE","COMMA_CODE","gobbleExpression","push","gobbleBinaryExpression","gobbleBinaryOp","to_check","substr","tc_len","isIdentifierPart","biop","prec","stack","biop_info","left","right","i","cur_biop","gobbleToken","binaryPrecedence","right_a","comparePrev","prev","pop","BINARY_EXP","operator","PERIOD_CODE","gobbleNumericLiteral","SQUOTE_CODE","DQUOTE_CODE","gobbleStringLiteral","OBRACK_CODE","gobbleArray","argument","UNARY_EXP","prefix","gobbleIdentifier","LITERAL","raw","this_str","THIS_EXP","OPAREN_CODE","gobbleGroup","gobbleTokenProperty","QUMARK_CODE","optional","MEMBER_EXP","computed","object","property","CBRACK_CODE","CALL_EXP","gobbleArguments","CPAREN_CODE","callee","chCode","number","parseFloat","str","startIndex","quote","closed","substring","start","IDENTIFIER","slice","termination","args","separator_count","arg","SEQUENCE_EXP","expressions","ARRAY_EXP","elements","first","arguments","Array","isArray","forEach","assign","plugins","jsep","registered","register","plugin","init","COLON_CODE","Set","stdClassProps","getOwnPropertyNames","filter","includes","undefined","m","ternary","test","consequent","alternate","newTest","ARROW_EXP","updateBinariesToArrows","values","val","params","addBinaryOp","backupIndex","addUnaryOp","callNode","getNumberCodeRanges","numType","getNumberBase","isUnderscoreOrWithinRange","ranges","some","min","gobbleBase10","gobbleDigits","JSON","stringify","parseInt","patternIndex","inCharSet","pattern","flags","RegExp","e","gobbleTemplateLiteral","gobbleMember","quasis","cooked","pushQuasi","tail","tag","quasi","bind","evaluate","expression","evaluateAsType","variables","defaultTypePredicate","evaluateAsync","evaluateAsTypeAsync","evaluateAsBoolean","booleanTypePredicate","evaluateAsBooleanAsync","evaluateAsNumber","numberTypePredicate","evaluateAsNumberAsync","typePredicate","createContextInternal","globals","createSynchronousContext","result","visitExpression","globalsAsync","createAsynchronousContext","Promise","resolve","then","reject","compile","Date","visitUnaryExpression","visitBinaryExpression","visitConditionalExpression","handleNullableExpression","Function","visitCallExpression","p","rest","join","vars","fromEntries","reduce","acc","idx","isValidVariableType","addVariables","thisObj","visitArrowFunctionExpression","objectName","visitExpressionName","ReferenceError","propertyName","TypeError","newObj","Number","validatePropertyName","visitMemberExpression","visitArrayExpression","visitSequenceExpression","visitNewExpression","visitLiteral","visitIdentifier","q","visitTemplateLiteral","visitTemplateElement","globals_","jsepArrow","jsepNew","jsepNumbers","jsepRegex","jsepTernary","jsepTemplate","Boolean","Infinity","NaN","BigInt","isFinite","isNaN","decodeURI","encodeURI","encodeURIComponent","__proto__","hasOwn","is"],"sourceRoot":""}