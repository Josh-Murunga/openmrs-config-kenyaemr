{"version":3,"file":"openmrs-esm-utils.js","mappings":"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","sources":["webpack://@openmrs/esm-routes/external system \"@openmrs/esm-config\"","webpack://@openmrs/esm-routes/external system \"@openmrs/esm-dynamic-loading\"","webpack://@openmrs/esm-routes/external system \"@openmrs/esm-extensions\"","webpack://@openmrs/esm-routes/external system \"@openmrs/esm-feature-flags\"","webpack://@openmrs/esm-routes/external system \"@openmrs/esm-utils\"","webpack://@openmrs/esm-routes/external system \"single-spa\"","webpack://@openmrs/esm-routes/webpack/bootstrap","webpack://@openmrs/esm-routes/webpack/runtime/define property getters","webpack://@openmrs/esm-routes/webpack/runtime/hasOwnProperty shorthand","webpack://@openmrs/esm-routes/webpack/runtime/make namespace object","webpack://@openmrs/esm-routes/./src/constants.ts","webpack://@openmrs/esm-routes/./src/loaders/helpers.ts","webpack://@openmrs/esm-routes/./src/loaders/app.ts","webpack://@openmrs/esm-routes/./src/loaders/components.ts","webpack://@openmrs/esm-routes/./src/loaders/pages.ts","webpack://@openmrs/esm-routes/./src/routes.ts"],"sourcesContent":["module.exports = __WEBPACK_EXTERNAL_MODULE__824__;","module.exports = __WEBPACK_EXTERNAL_MODULE__758__;","module.exports = __WEBPACK_EXTERNAL_MODULE__45__;","module.exports = __WEBPACK_EXTERNAL_MODULE__708__;","module.exports = __WEBPACK_EXTERNAL_MODULE__618__;","module.exports = __WEBPACK_EXTERNAL_MODULE__645__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const localStorageRoutesPrefix = 'openmrs-routes:';\n","import { type LifeCycles } from 'single-spa';\n\nexport const emptyLifecycle: LifeCycles<never> = {\n  bootstrap() {\n    return Promise.resolve();\n  },\n  mount() {\n    return Promise.resolve();\n  },\n  unmount() {\n    return Promise.resolve();\n  },\n};\n\nexport function routeRegex(regex: RegExp, location: Location) {\n  const result = regex.test(location.pathname.replace(window.getOpenmrsSpaBase(), ''));\n  return result;\n}\n","import { importDynamic } from '@openmrs/esm-dynamic-loading';\nimport { type LifeCycles } from 'single-spa';\nimport { emptyLifecycle } from './helpers';\n\n// Couldn't figure out how to express this as an interface\ntype Module = Omit<Record<string, () => LifeCycles | Promise<LifeCycles>>, 'startupApp'> & {\n  startupApp?: () => unknown;\n};\n\n/**\n * @internal\n *\n * Used internally to track which apps have had their `startupApp()` initializer called\n *\n * Values are promises to support asynchronous loading of the same app multiple times\n */\nconst initializedApps = new Map<string, Promise<unknown>>();\n\n/**\n * This function creates a loader function suitable for use in either a single-spa\n * application or parcel.\n *\n * The returned function is lazy and ensures that the appropriate module is loaded,\n * that the module's `startupApp()` is called before the component is loaded. It\n * then calls the component function, which should return either a single-spa\n * {@link LifeCycles} object or a {@link Promise} that will resolve to such an object.\n *\n * React-based pages or extensions should generally use the framework's\n * `getAsyncLifecycle()` or `getSyncLifecycle()` functions.\n */\nexport function getLoader(appName: string, component: string): () => Promise<LifeCycles> {\n  return async () => {\n    const module = await importDynamic<Module>(appName);\n\n    if (module && Object.hasOwn(module, component) && typeof module[component] === 'function') {\n      return initializeApp(appName, module).then(() => module[component]());\n    } else {\n      if (module && Object.hasOwn(module, component)) {\n        console.warn(`The export ${component} of the app ${appName} is not a function`);\n      } else {\n        console.warn(`The app ${appName} does not define a component called ${component}, this cannot be loaded`);\n      }\n    }\n\n    return emptyLifecycle;\n  };\n}\n\n/**\n * This function can be used to manually initialize an application without waiting for the\n * framework to load it. This can sometimes be helpful if the framework doesn't load code\n * at the point you think is appropriate.\n *\n * This will ensure that the module is available and that it's `startupApp()` function (if\n * any) will be called. Note that these are only guaranteed to be complete once the Promise\n * returned from the function completes.\n *\n * @param appName The name of the app to initialize\n * @param module The loaded code module, if available; if this parameter is omitted, this\n *   function will load it.\n * @returns a Promise which completes once the app has been loaded and initialized\n */\nexport async function initializeApp(appName: string, module?: Module) {\n  if (!(appName in initializedApps)) {\n    let _module: Module = module ?? (await importDynamic<Module>(appName));\n\n    await (initializedApps[appName] = new Promise((resolve, reject) => {\n      if (Object.hasOwn(_module, 'startupApp')) {\n        const startup = _module['startupApp'];\n        if (typeof startup === 'function') {\n          return Promise.resolve(startup()).then(resolve).catch(reject);\n        }\n      }\n\n      resolve(null);\n    }));\n  } else {\n    await initializedApps[appName];\n  }\n}\n","import {\n  attach,\n  type ExtensionRegistration,\n  registerExtension,\n  registerModal,\n  registerWorkspace,\n} from '@openmrs/esm-extensions';\nimport {\n  type FeatureFlagDefinition,\n  type ExtensionDefinition,\n  type ModalDefinition,\n  type WorkspaceDefinition,\n} from '@openmrs/esm-globals';\nimport { getLoader } from './app';\nimport { FeatureFlag, registerFeatureFlag } from '@openmrs/esm-feature-flags';\n\n/**\n * This function registers an extension definition with the framework and will\n * attach the extension to any configured slots.\n *\n * @param appName The name of the app containing this extension\n * @param extension An object that describes the extension, derived from `routes.json`\n */\nexport function tryRegisterExtension(appName: string, extension: ExtensionDefinition) {\n  const name = extension.name;\n  if (!name) {\n    console.error(\n      `An extension definition in ${appName} is missing an name and thus cannot be\nregistered. To fix this, ensure that you define the \"name\" field inside the\nextension definition.`,\n      extension,\n    );\n    return;\n  }\n\n  if (extension.slots && extension.slot) {\n    console.warn(\n      `The extension ${name} from ${appName} declares both a 'slots' property and\na 'slot' property. Only the 'slots' property will be honored.`,\n    );\n  }\n  const slots = extension.slots ? extension.slots : extension.slot ? [extension.slot] : [];\n\n  if (!extension.component && !extension.load) {\n    console.error(\n      `The extension ${name} from ${appName} is missing a 'component' entry and thus cannot be registered.\nTo fix this, ensure that you define a 'component' field inside the extension definition.`,\n      extension,\n    );\n    return;\n  }\n\n  let loader: ExtensionRegistration['load'] | undefined = undefined;\n  if (extension.component) {\n    loader = getLoader(appName, extension.component);\n  } else if (extension.load) {\n    if (typeof extension.load !== 'function') {\n      console.error(\n        `The extension ${name} from ${appName} declares a 'load' property that is not a function. This is not\nsupported, so the extension will not be loaded.`,\n      );\n      return;\n    }\n    loader = extension.load;\n  }\n\n  if (loader) {\n    registerExtension({\n      name,\n      load: loader,\n      meta: extension.meta || {},\n      order: extension.order,\n      moduleName: appName,\n      privileges: extension.privileges,\n      online: extension.online ?? true,\n      offline: extension.offline ?? false,\n      featureFlag: extension.featureFlag,\n    });\n  }\n\n  for (const slot of slots) {\n    attach(slot, name);\n  }\n}\n\n/**\n * This function registers a modal definition with the framework so that it can be launched.\n *\n * @param appName The name of the app defining this modal\n * @param modal An object that describes the modal, derived from `routes.json`\n */\nexport function tryRegisterModal(appName: string, modal: ModalDefinition) {\n  const name = modal.name;\n  if (!name) {\n    console.error(\n      `A modal definition in ${appName} is missing an name and thus cannot be\nregistered. To fix this, ensure that you define the \"name\" field inside the\nmodal definition.`,\n      modal,\n    );\n    return;\n  }\n\n  if (!modal.component && !modal.load) {\n    console.error(\n      `The modal ${name} from ${appName} is missing a 'component' entry and thus cannot be registered.\nTo fix this, ensure that you define a 'component' field inside the modal definition.`,\n      modal,\n    );\n    return;\n  }\n\n  let loader: ExtensionRegistration['load'] | undefined = undefined;\n  if (modal.component) {\n    loader = getLoader(appName, modal.component);\n  } else if (modal.load) {\n    if (typeof modal.load !== 'function') {\n      console.error(\n        `The modal ${name} from ${appName} declares a 'load' property that is not a function. This is not\nsupported, so the modal will not be loaded.`,\n      );\n      return;\n    }\n    loader = modal.load;\n  }\n\n  if (loader) {\n    registerModal({\n      name,\n      load: loader,\n      moduleName: appName,\n    });\n  }\n}\n\n/**\n * This function registers a workspace definition with the framework so that it can be launched.\n *\n * @param appName The name of the app defining this workspace\n * @param workspace An object that describes the workspace, derived from `routes.json`\n */\nexport function tryRegisterWorkspace(appName: string, workspace: WorkspaceDefinition) {\n  const name = workspace.name;\n  if (!name) {\n    console.error(\n      `A workspace definition in ${appName} is missing a name and thus cannot be registered.\nTo fix this, ensure that you define the \"name\" field inside the workspace definition.`,\n      workspace,\n    );\n    return;\n  }\n\n  const title = workspace.title;\n  if (!title) {\n    console.error(\n      `A workspace definition in ${appName} is missing a title and thus cannot be registered.\nTo fix this, ensure that you define the \"title\" field inside the workspace definition.`,\n      workspace,\n    );\n    return;\n  }\n\n  if (!workspace.component && !workspace.load) {\n    console.error(\n      `The workspace ${name} from ${appName} is missing a 'component' entry and thus cannot be registered.\nTo fix this, ensure that you define a 'component' field inside the workspace definition.`,\n      workspace,\n    );\n    return;\n  }\n\n  let loader: ExtensionRegistration['load'] | undefined = undefined;\n  if (workspace.component) {\n    loader = getLoader(appName, workspace.component);\n  } else if (workspace.load) {\n    if (typeof workspace.load !== 'function') {\n      console.error(\n        `The workspace ${name} from ${appName} declares a 'load' property that is not a function. This is not\nsupported, so the workspace will not be loaded.`,\n      );\n      return;\n    }\n    loader = workspace.load;\n  }\n\n  if (loader) {\n    registerWorkspace({\n      name,\n      title,\n      load: loader,\n      moduleName: appName,\n      type: workspace.type,\n      canHide: workspace.canHide,\n      canMaximize: workspace.canMaximize,\n      width: workspace.width,\n      cancelTitle: workspace.cancelTitle,\n      cancelMessage: workspace.cancelMessage,\n      cancelConfirmText: workspace.cancelConfirmText,\n      hasOwnSidebar: workspace.hasOwnSidebar,\n      sidebarFamily: workspace.sidebarFamily,\n      preferredWindowSize: workspace.preferredWindowSize,\n    });\n  }\n}\n\n/**\n * This function registers a workspace definition with the framework so that it can be launched.\n *\n * @param appName The name of the app defining this workspace\n * @param workspace An object that describes the workspace, derived from `routes.json`\n */\nexport function tryRegisterFeatureFlag(appName: string, featureFlag: FeatureFlagDefinition) {\n  const name = featureFlag.flagName;\n  if (!name) {\n    console.error(\n      `A feature flag definition in ${appName} is missing a name and thus cannot be registered.\nTo fix this, ensure that you define the \"name\" field inside the feature flag definition.`,\n      featureFlag,\n    );\n    return;\n  }\n\n  const label = featureFlag.label;\n  if (!label) {\n    console.error(\n      `A feature flag definition in ${appName} is missing a description and thus cannot be registered.\nTo fix this, ensure that you define the \"label\" field inside the feature flag definition.`,\n      featureFlag,\n    );\n    return;\n  }\n\n  const description = featureFlag.description;\n  if (!description) {\n    console.error(\n      `A feature flag definition in ${appName} is missing a description and thus cannot be registered.\nTo fix this, ensure that you define the \"description\" field inside the feature flag definition.`,\n      featureFlag,\n    );\n    return;\n  }\n\n  registerFeatureFlag(featureFlag.flagName, featureFlag.label, featureFlag.description);\n}\n","import { type ActivityFn, pathToActiveWhen, registerApplication } from 'single-spa';\nimport { registerModuleWithConfigSystem } from '@openmrs/esm-config';\nimport {\n  type ExtensionDefinition,\n  type FeatureFlagDefinition,\n  type ModalDefinition,\n  type OpenmrsAppRoutes,\n  type RegisteredPageDefinition,\n  type RouteDefinition,\n  type WorkspaceDefinition,\n} from '@openmrs/esm-globals';\nimport { getFeatureFlag } from '@openmrs/esm-feature-flags';\nimport { routeRegex } from './helpers';\nimport { getLoader } from './app';\nimport { tryRegisterExtension, tryRegisterFeatureFlag, tryRegisterModal, tryRegisterWorkspace } from './components';\n\n// this is the global holder of all pages registered in the app\nconst pages: Array<RegisteredPageDefinition> = [];\n\n/**\n * This takes a page's route definitions and returns a single-spa\n * activityFn which returns true when the page matches the current\n * route and false if it does not.\n *\n * @param route A string or regexp that matches the location when the\n * page should be displayed, a boolean constant, or an array of such\n * strings, regexps, and booleans\n * @returns An activityFn suitable to use for a single-spa application\n */\nfunction getActivityFn(route: RouteDefinition | Array<RouteDefinition>): ActivityFn {\n  if (Array.isArray(route)) {\n    const activators = route.map(getActivityFn);\n    return (location) => activators.some((activator) => activator(location));\n  } else if (typeof route === 'string') {\n    return pathToActiveWhen(window.getOpenmrsSpaBase() + route);\n  } else if (route instanceof RegExp) {\n    return (location) => routeRegex(route, location);\n  } else {\n    return () => route;\n  }\n}\n\n/**\n * For pages, we also add support for rendered them based on online and offline mode as well as\n * any feature flags.\n *\n * By default, we assume that all pages should be rendered when online, but only rendered\n * offline if specifically configured to do so.\n *\n * @param activityFn A standard single-spa activityFn such as that returned by {@link getActivityFn()}\n * @param pageDefinition The RegisteredPageDefinition object for this page\n * @returns An activityFn suitable to use for a single-spa application\n */\nfunction wrapPageActivityFn(\n  activityFn: ActivityFn,\n  { online, offline, featureFlag }: RegisteredPageDefinition,\n): ActivityFn {\n  if (window.offlineEnabled) {\n    return (location) => {\n      // basically, if the page should only work online and we're offline or if the\n      // page should only work offline and we're online, defaulting to always rendering\n      // the page\n      if (!((navigator.onLine && (online ?? true)) || (!navigator.onLine && (offline ?? false)))) {\n        return false;\n      }\n\n      if (featureFlag) {\n        if (!getFeatureFlag(featureFlag)) {\n          return false;\n        }\n      }\n\n      return activityFn(location);\n    };\n  } else {\n    return activityFn;\n  }\n}\n\n/**\n * This is the main entry-point for registering an app with the app shell.\n * Each app has a name and should have a `routes.json` file that defines it's\n * associated routes.\n *\n * @param appName The name of the application, e.g. `@openmrs/esm-my-app`\n * @param routes A Javascript object that corresponds to the app's  routes.json`\n * definition.\n */\nexport function registerApp(appName: string, routes: OpenmrsAppRoutes) {\n  if (appName && routes && typeof routes === 'object') {\n    registerModuleWithConfigSystem(appName);\n\n    const availableExtensions: Array<ExtensionDefinition> = routes.extensions ?? [];\n    const availableModals: Array<ModalDefinition> = routes.modals ?? [];\n    const availableWorkspaces: Array<WorkspaceDefinition> = routes.workspaces ?? [];\n    const availableFeatureFlags: Array<FeatureFlagDefinition> = routes.featureFlags ?? [];\n\n    routes.pages?.forEach((p) => {\n      if (\n        p &&\n        typeof p === 'object' &&\n        Object.hasOwn(p, 'component') &&\n        (Object.hasOwn(p, 'route') || Object.hasOwn(p, 'routeRegex') || Object.hasOwn(p, 'routes'))\n      ) {\n        pages.push({\n          ...p,\n          order: p.order ?? Number.MAX_SAFE_INTEGER,\n          appName,\n        });\n      } else {\n        console.warn(\n          `A page for ${appName} could not be registered as it does not appear to have the required properties`,\n          p,\n        );\n      }\n    });\n\n    availableExtensions.forEach((ext) => {\n      if (ext && typeof ext === 'object' && Object.hasOwn(ext, 'name') && Object.hasOwn(ext, 'component')) {\n        tryRegisterExtension(appName, ext);\n      } else {\n        console.warn(\n          `An extension for ${appName} could not be registered as it does not appear to have the required properties`,\n          ext,\n        );\n      }\n    });\n\n    availableModals.forEach((modal) => {\n      if (modal && typeof modal === 'object' && Object.hasOwn(modal, 'name') && Object.hasOwn(modal, 'component')) {\n        tryRegisterModal(appName, modal);\n      } else {\n        console.warn(\n          `A modal for ${appName} could not be registered as it does not appear to have the required properties`,\n          modal,\n        );\n      }\n    });\n\n    availableWorkspaces.forEach((workspace) => {\n      if (\n        workspace &&\n        typeof workspace === 'object' &&\n        Object.hasOwn(workspace, 'name') &&\n        Object.hasOwn(workspace, 'component')\n      ) {\n        tryRegisterWorkspace(appName, workspace);\n      } else {\n        console.warn(\n          `A workspace for ${appName} could not be registered as it does not appear to have the required properties`,\n          workspace,\n        );\n      }\n    });\n\n    availableFeatureFlags.forEach((featureFlag) => {\n      if (featureFlag && typeof featureFlag === 'object' && Object.hasOwn(featureFlag, 'flagName')) {\n        tryRegisterFeatureFlag(appName, featureFlag);\n      } else {\n        console.warn(\n          `A feature flag for ${appName} could not be registered as it does not appear to have the required properties`,\n          featureFlag,\n        );\n      }\n    });\n  }\n}\n\n/**\n * This is called by the app shell once all route entries have been processed.\n * This actually registers the pages with the application. This function is\n * necessary to ensure that pages are rendered in the DOM according to their\n * order definition, especially because certain pages _must_ be first in the DOM.\n *\n * Each page is rendered into a div with an appropriate name.\n */\nexport function finishRegisteringAllApps() {\n  pages.sort((a, b) => {\n    let sort = a.order - b.order;\n    if (sort != 0) {\n      return sort;\n    }\n    return a.appName.localeCompare(b.appName, 'en');\n  });\n\n  // Create a div for each page. This ensures their DOM order.\n  // If we don't do this, Single-SPA 5 will create the DOM element only once\n  // the page becomes active, which makes it impossible to guarantee order.\n  let appIndices = new Map();\n  for (let page of pages) {\n    if (!appIndices.has(page.appName)) {\n      appIndices.set(page.appName, 0);\n    } else {\n      appIndices.set(page.appName, appIndices.get(page.appName) + 1);\n    }\n    const index = appIndices.get(page.appName);\n\n    const name = `${page.appName}-page-${index}`;\n    const div = document.createElement('div');\n    div.id = `single-spa-application:${name}`;\n    document.body.appendChild(div);\n    tryRegisterPage(name, page);\n  }\n}\n\n/**\n * This function converts each page definition into a single-spa application\n * if that's possible. After this point, pages are rendered using single-spa's\n * routing logic.\n *\n * @param appName The name of the app containing this page\n * @param page An object that describes the page, derived from `routes.json`\n */\nfunction tryRegisterPage(appName: string, page: RegisteredPageDefinition) {\n  const route =\n    typeof page.route !== 'undefined'\n      ? page.route\n      : typeof page.routeRegex !== 'undefined'\n        ? new RegExp(page.routeRegex)\n        : false;\n\n  if (route === false) {\n    console.warn(\n      `A registered page definition is missing a route and thus cannot be registered.\nTo fix this, ensure that you define the \"route\" (or alternatively the \"routeRegex\") field inside the extension definition.`,\n      appName,\n    );\n    return;\n  }\n\n  if (!page.component) {\n    console.warn(\n      `A registered page definition is missing a component and thus cannot be registered.\nTo fix this, ensure that you define the \"component\" field inside the page definition.`,\n      appName,\n    );\n    return;\n  }\n\n  const activityFn = wrapPageActivityFn(getActivityFn(route), page);\n  const loader = getLoader(page.appName, page.component);\n  registerApplication(appName, loader, activityFn);\n}\n","/** @module @category Routes Utilities */\nimport type { OpenmrsAppRoutes, OpenmrsRoutes } from '@openmrs/esm-globals';\nimport { canAccessStorage } from '@openmrs/esm-utils';\nimport { localStorageRoutesPrefix } from './constants';\n\nconst isEnabled = canAccessStorage();\n\n/**\n * Used to add a route override to local storage. These are read as the routes registry\n * is assembled, so the app must be reloaded for new overrides to take effect.\n *\n * @internal\n * @param moduleName The name of the module the routes are for\n * @param routes Either an {@link OpenmrsAppRoutes} object, a string that represents a JSON\n *  version of an {@link OpenmrsAppRoutes} object or a string or URL that resolves to a\n *  JSON document that represents an {@link OpenmrsAppRoutes} object\n */\nexport function addRoutesOverride(moduleName: string, routes: OpenmrsAppRoutes | string | URL) {\n  if (!isEnabled) {\n    return;\n  }\n\n  if (typeof routes === 'string') {\n    if (routes.startsWith('http')) {\n      return addRouteOverrideInternal(moduleName, routes);\n    } else {\n      try {\n        const maybeRoutes = JSON.parse(routes);\n        if (isOpenmrsAppRoutes(maybeRoutes)) {\n          return addRouteOverrideInternal(moduleName, maybeRoutes);\n        } else {\n          console.error(`The supplied routes for ${moduleName} is not a valid OpenmrsAppRoutes object`, routes);\n        }\n      } catch (e) {\n        console.error(`Could not add routes override for ${moduleName}: `, e);\n      }\n    }\n  } else if (routes instanceof URL) {\n    return addRouteOverrideInternal(moduleName, routes.toString());\n  } else if (isOpenmrsAppRoutes(routes)) {\n    return addRouteOverrideInternal(moduleName, routes);\n  }\n\n  console.error(\n    `Override for ${moduleName} is not in a valid format. Expected either a Javascript Object, a JSON string of a Javascript object, or a URL`,\n    routes,\n  );\n}\n\n/**\n * Used to remove an existing routes override from local storage. These are read as the routes registry\n * is assembled, so the app must be reloaded for removed override to be removed.\n *\n * @internal\n * @param moduleName The module to remove the overrides for\n */\nexport function removeRoutesOverride(moduleName: string) {\n  if (!isEnabled) {\n    return;\n  }\n\n  const key = localStorageRoutesPrefix + moduleName;\n  localStorage.removeItem(key);\n}\n\n/**\n * Used to remove all existing routes overrides from local storage. These are read as the routes registry\n * is assembled, so the app must be reloaded for the removed overrides to appear to be removed.\n *\n * @internal\n */\nexport function resetAllRoutesOverrides() {\n  if (!isEnabled) {\n    return;\n  }\n\n  const localStorage = window.localStorage;\n  for (let i = 0; i < localStorage.length; i++) {\n    const key = localStorage.key(i);\n    if (key?.startsWith(localStorageRoutesPrefix)) {\n      localStorage.removeItem(key);\n    }\n  }\n}\n\nfunction addRouteOverrideInternal(moduleName: string, routes: OpenmrsAppRoutes | string) {\n  const key = localStorageRoutesPrefix + moduleName;\n  localStorage.setItem(key, JSON.stringify(routes));\n}\n\n/**\n * Simple type-predicate to ensure that the value can be treated as an OpenmrsAppRoutes\n * object.\n *\n * @internal\n * @param routes the object to check to see if it is an OpenmrsAppRoutes object\n * @returns true if the routes value is an OpenmrsAppRoutes\n */\nexport function isOpenmrsAppRoutes(routes: OpenmrsAppRoutes | unknown): routes is OpenmrsAppRoutes {\n  if (routes && typeof routes === 'object') {\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\n    // we cast maybeRoutes as OpenmrsAppRoutes mainly so we can refer to the properties it should\n    // have without repeated casts\n    const maybeRoutes = routes as OpenmrsAppRoutes;\n\n    if (hasOwnProperty.call(routes, 'pages')) {\n      if (!Boolean(maybeRoutes.pages) || !Array.isArray(maybeRoutes.pages)) {\n        return false;\n      }\n    }\n\n    if (hasOwnProperty.call(routes, 'extensions')) {\n      if (!Boolean(maybeRoutes.extensions) || !Array.isArray(maybeRoutes.extensions)) {\n        return false;\n      }\n    }\n\n    if (hasOwnProperty.call(routes, 'workspaces')) {\n      if (!Boolean(maybeRoutes.workspaces) || !Array.isArray(maybeRoutes.workspaces)) {\n        return false;\n      }\n    }\n\n    if (hasOwnProperty.call(routes, 'modals')) {\n      if (!Boolean(maybeRoutes.modals) || !Array.isArray(maybeRoutes.modals)) {\n        return false;\n      }\n    }\n\n    // Notice that we're essentially testing for things that cannot be treated as an OpenmrsAppRoutes\n    // object. This is because a completely empty object is a valid OpenmrsAppRoutes object.\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Simple type-predicate to ensure that the value can be treated as an OpenmrsRoutes\n * object.\n *\n * @internal\n * @param routes the object to check to see if it is an OpenmrsRoutes object\n * @returns true if the routes value is an OpenmrsRoutes\n */\nexport function isOpenmrsRoutes(routes: OpenmrsRoutes | unknown): routes is OpenmrsRoutes {\n  if (routes && typeof routes === 'object') {\n    const maybeRoutes = routes as OpenmrsRoutes;\n\n    return Object.entries(maybeRoutes).every(([key, value]) => typeof key === 'string' && isOpenmrsAppRoutes(value));\n  }\n\n  return false;\n}\n"],"names":["module","exports","__WEBPACK_EXTERNAL_MODULE__824__","__WEBPACK_EXTERNAL_MODULE__758__","__WEBPACK_EXTERNAL_MODULE__45__","__WEBPACK_EXTERNAL_MODULE__708__","__WEBPACK_EXTERNAL_MODULE__618__","__WEBPACK_EXTERNAL_MODULE__645__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","localStorageRoutesPrefix","emptyLifecycle","bootstrap","Promise","resolve","mount","unmount","initializedApps","Map","getLoader","appName","component","importDynamic","hasOwn","initializeApp","then","console","warn","_module","reject","startup","catch","tryRegisterExtension","extension","name","slots","slot","load","loader","error","registerExtension","meta","order","moduleName","privileges","online","offline","featureFlag","attach","pages","getActivityFn","route","Array","isArray","activators","map","location","some","activator","pathToActiveWhen","window","getOpenmrsSpaBase","RegExp","regex","test","pathname","replace","routeRegex","registerApp","routes","registerModuleWithConfigSystem","availableExtensions","extensions","availableModals","modals","availableWorkspaces","workspaces","availableFeatureFlags","featureFlags","forEach","p","push","Number","MAX_SAFE_INTEGER","ext","modal","registerModal","tryRegisterModal","workspace","title","registerWorkspace","type","canHide","canMaximize","width","cancelTitle","cancelMessage","cancelConfirmText","hasOwnSidebar","sidebarFamily","preferredWindowSize","tryRegisterWorkspace","flagName","label","description","registerFeatureFlag","tryRegisterFeatureFlag","finishRegisteringAllApps","sort","a","b","localeCompare","appIndices","page","has","set","index","div","document","createElement","id","body","appendChild","tryRegisterPage","activityFn","offlineEnabled","navigator","onLine","getFeatureFlag","wrapPageActivityFn","registerApplication","isEnabled","canAccessStorage","addRoutesOverride","startsWith","addRouteOverrideInternal","maybeRoutes","JSON","parse","isOpenmrsAppRoutes","e","URL","toString","removeRoutesOverride","localStorage","removeItem","resetAllRoutesOverrides","i","length","setItem","stringify","Boolean","isOpenmrsRoutes","entries","every"],"sourceRoot":""}